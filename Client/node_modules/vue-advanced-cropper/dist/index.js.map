{"version":3,"file":"index.js","sources":["../node_modules/classnames/index.js","../node_modules/easy-bem/index.js","../node_modules/debounce/index.js","../node_modules/tslib/tslib.es6.js","../src/core/utils.ts","../src/core/events.ts","../node_modules/rollup-plugin-vue/node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../src/components/service/DraggableElement.vue","../src/mixins/draggable.js","../src/core/constants.ts","../src/core/service.ts","../src/core/algorithms/approximatedSize.ts","../src/core/algorithms/move.ts","../src/core/algorithms/applyTransform.ts","../src/core/algorithms/autoZoom.ts","../src/core/algorithms/defaultSize.ts","../src/core/algorithms/limitBy.ts","../src/core/algorithms/manipulateImage.ts","../src/core/algorithms/rotateImage.ts","../src/core/algorithms/flipImage.ts","../src/core/algorithms/resize.ts","../src/components/handlers/SimpleHandler.vue","../src/core/image.ts","../src/components/service/PreviewResult.vue","../src/core/touch.ts","../src/components/service/CropperWrapper.vue","../src/core/algorithms/defaultPosition.ts","../src/core/algorithms/defaultVisibleArea.ts","../src/core/algorithms/initStretcher.ts","../src/core/algorithms/fitCoordinates.ts","../src/core/algorithms/fitVisibleArea.ts","../src/core/algorithms/areaRestrictions.ts","../src/core/algorithms/sizeRestrictions.ts","../src/core/algorithms/positionRestrictions.ts","../src/core/algorithms/refineSizeRestrictions.ts","../src/core/algorithms/roundCoordinates.ts","../src/core/algorithms/normalizeEvent.ts","../src/core/canvas.ts","../src/core/algorithms/defaultBoundaries.ts","../src/core/algorithms/refineVisibleArea.ts","../src/core/algorithms/stencil.ts","../src/index.js"],"sourcesContent":["/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","'use strict';\r\n\r\n/**\r\n * BEM class name factory.\r\n *\r\n * @typedef {Function} Bem\r\n * @param {String|Object} [elementOrMods] Element name or hash object with mods\r\n * @param {Object} [mods] Hash object with mods\r\n * @returns {String}\r\n */\r\n\r\n/**\r\n * Returns BEM class name factory.\r\n *\r\n * @param {String} componentName Block name\r\n * @returns {Bem}\r\n */\r\nmodule.exports = function bem(componentName) {\r\n    return function (elementOrMods, mods) {\r\n        if (!elementOrMods) {\r\n            return componentName;\r\n        }\r\n\r\n        var element;\r\n\r\n        if (typeof elementOrMods === 'string') {\r\n            element = elementOrMods;\r\n        } else {\r\n            mods = elementOrMods;\r\n        }\r\n\r\n        var base = componentName;\r\n        if (element) {\r\n            base += '__' + element;\r\n        }\r\n\r\n        return base + (\r\n            mods\r\n                ? Object.keys(mods).reduce(function (result, name) {\r\n                    var value = mods[name];\r\n\r\n                    if (value) {\r\n                        result += ' ' + (\r\n                            typeof value === 'boolean'\r\n                                ? (base + '--' + name)\r\n                                : (base + '--' + name + '_' + value)\r\n                        );\r\n                    }\r\n\r\n                    return result;\r\n                }, '')\r\n                : ''\r\n        );\r\n    };\r\n}\r\n","/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\nfunction debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\n// Adds compatibility for ES modules\ndebounce.debounce = debounce;\n\nmodule.exports = debounce;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","type Protocol = 'http' | 'https';\r\n\r\nexport function directionNames(hDirection, vDirection) {\r\n\tlet name, classname;\r\n\tif (hDirection && vDirection) {\r\n\t\tname = `${hDirection}${vDirection[0].toUpperCase()}${vDirection.slice(1)}`;\r\n\t\tclassname = `${hDirection}-${vDirection}`;\r\n\t} else {\r\n\t\tname = hDirection || vDirection;\r\n\t\tclassname = hDirection || vDirection;\r\n\t}\r\n\treturn { name, classname };\r\n}\r\n\r\nexport function isLocal(url: string) {\r\n\treturn /^data:/.test(url) || /^blob:/.test(url);\r\n}\r\n\r\nexport function isCrossOriginURL(url: string) {\r\n\tif (isLocal(url)) {\r\n\t\treturn false;\r\n\t}\r\n\tconst pageLocation = window.location;\r\n\tconst URL_HOST_PATTERN = /(\\w+:)?(?:\\/\\/)([\\w.-]+)?(?::(\\d+))?\\/?/;\r\n\tconst urlMatch = URL_HOST_PATTERN.exec(url) || [];\r\n\tconst urlparts = {\r\n\t\tprotocol: urlMatch[1] || '',\r\n\t\thost: urlMatch[2] || '',\r\n\t\tport: urlMatch[3] || '',\r\n\t};\r\n\r\n\tconst defaultPort = (protocol: Protocol) => {\r\n\t\tif (protocol === 'http') {\r\n\t\t\treturn 80;\r\n\t\t} else {\r\n\t\t\treturn 433;\r\n\t\t}\r\n\t};\r\n\r\n\tconst portOf = (location: any) => {\r\n\t\treturn location.port || defaultPort((location.protocol || pageLocation.protocol) as Protocol);\r\n\t};\r\n\r\n\treturn !(\r\n\t\t(!urlparts.protocol && !urlparts.host && !urlparts.port) ||\r\n\t\tBoolean(\r\n\t\t\turlparts.protocol &&\r\n\t\t\t\turlparts.protocol == pageLocation.protocol &&\r\n\t\t\t\turlparts.host &&\r\n\t\t\t\turlparts.host == pageLocation.host &&\r\n\t\t\t\turlparts.host &&\r\n\t\t\t\tportOf(urlparts) == portOf(pageLocation),\r\n\t\t)\r\n\t);\r\n}\r\n\r\nexport function isFunction(obj: any) {\r\n\treturn !!(obj && obj.constructor && obj.call && obj.apply);\r\n}\r\n\r\nexport function isUndefined(obj: any): boolean {\r\n\treturn obj === undefined;\r\n}\r\n\r\nexport function isObject(obj) {\r\n\treturn typeof obj === 'object' && obj !== null;\r\n}\r\n\r\nexport function getOptions(options: any, defaultScheme: any, falseScheme: any) {\r\n\tconst result: any = {};\r\n\tif (isObject(options)) {\r\n\t\tObject.keys(defaultScheme).forEach((key) => {\r\n\t\t\tif (isUndefined(options[key])) {\r\n\t\t\t\tresult[key] = defaultScheme[key];\r\n\t\t\t} else if (isObject(defaultScheme[key])) {\r\n\t\t\t\tif (isObject(options[key])) {\r\n\t\t\t\t\tresult[key] = getOptions(options[key], defaultScheme[key], falseScheme[key]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult[key] = options[key] ? defaultScheme[key] : falseScheme[key];\r\n\t\t\t\t}\r\n\t\t\t} else if (defaultScheme[key] === true || defaultScheme[key] === false) {\r\n\t\t\t\tresult[key] = Boolean(options[key]);\r\n\t\t\t} else {\r\n\t\t\t\tresult[key] = options[key];\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn result;\r\n\t} else {\r\n\t\tif (options) {\r\n\t\t\treturn defaultScheme;\r\n\t\t} else {\r\n\t\t\treturn falseScheme;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function getSettings<T extends {}>(param, defaultParams?: T) {\r\n\tlet result = {\r\n\t\tenabled: Boolean(param),\r\n\t\t...defaultParams,\r\n\t};\r\n\tif (isObject(param)) {\r\n\t\tresult = { ...result, ...param };\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nexport function parseNumber(number) {\r\n\tconst parsedNumber = Number(number);\r\n\tif (Number.isNaN(parsedNumber)) {\r\n\t\treturn number;\r\n\t} else {\r\n\t\treturn parsedNumber;\r\n\t}\r\n}\r\n\r\nexport function replacedProp(value, oldName, currentName) {\r\n\tif (!isEmpty(value) && process.env.NODE_ENV !== 'production') {\r\n\t\tconsole.warn(`Warning: prop \"${oldName}\" is deprecated, use \"${currentName}\" instead. Value:`, value);\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nexport function isEmpty(obj) {\r\n\treturn (!obj || Object.keys(obj).length === 0) && typeof obj !== 'function';\r\n}\r\n\r\nexport function isObjectLike(value) {\r\n\treturn typeof value === 'object' && value !== null;\r\n}\r\n\r\nexport function isNumber(value) {\r\n\treturn (\r\n\t\ttypeof (value == 'number' || (isObjectLike(value) && toString.call(value) == '[object Number]')) &&\r\n\t\t!isNaN(value)\r\n\t);\r\n}\r\n\r\nexport function isNaN(value) {\r\n\treturn value !== value;\r\n}\r\n\r\nexport function isLoadedImage(image) {\r\n\treturn Boolean(image.naturalWidth);\r\n}\r\n\r\nexport function distance(firstPoint, secondPoint) {\r\n\treturn Math.sqrt(Math.pow(firstPoint.x - secondPoint.x, 2) + Math.pow(firstPoint.y - secondPoint.y, 2));\r\n}\r\n\r\nexport function isApproximatelyEqual(a: number, b: number, precision = 0.001) {\r\n\tif (a === 0 || b === 0) {\r\n\t\treturn Math.abs(b - a) < precision;\r\n\t} else {\r\n\t\treturn Math.abs(b / a) < 1 + precision && Math.abs(b / a) > 1 - precision;\r\n\t}\r\n}\r\n\r\nexport function sign(value) {\r\n\tconst number = +value;\r\n\tif (number === 0 || isNaN(number)) {\r\n\t\treturn number;\r\n\t}\r\n\treturn number > 0 ? 1 : -1;\r\n}\r\n\r\nexport function radians(angle: number) {\r\n\treturn (angle * Math.PI) / 180;\r\n}\r\n","import { StencilEvent, Diff, MoveDirections, Point, ResizeDirections, Scale } from './typings';\r\n\r\nexport class ManipulateImageEvent implements StencilEvent {\r\n\ttype: 'manipulateImage';\r\n\tnativeEvent: Event;\r\n\tmove: Partial<MoveDirections>;\r\n\tscale: Partial<Scale>;\r\n\tconstructor(move: Partial<MoveDirections> = {}, scale: Partial<Scale> = {}) {\r\n\t\tthis.type = 'manipulateImage';\r\n\t\tthis.move = move;\r\n\t\tthis.scale = scale;\r\n\t}\r\n}\r\n\r\nexport interface ResizeEventParams {\r\n\tcompensate?: boolean;\r\n\tpreserveRatio?: boolean;\r\n\tallowedDirections?: ResizeDirections;\r\n\trespectDirection?: 'width' | 'height';\r\n}\r\n\r\nexport class ResizeEvent implements StencilEvent {\r\n\ttype: 'resize';\r\n\tdirections: ResizeDirections;\r\n\tparams: ResizeEventParams;\r\n\r\n\tconstructor(directions: ResizeDirections, params: ResizeEventParams = {}) {\r\n\t\tthis.type = 'resize';\r\n\t\tthis.directions = directions;\r\n\t\tthis.params = params;\r\n\t}\r\n}\r\n\r\nexport class MoveEvent implements StencilEvent {\r\n\ttype: 'move';\r\n\tdirections: MoveDirections;\r\n\r\n\tconstructor(directions: MoveDirections) {\r\n\t\tthis.type = 'move';\r\n\t\tthis.directions = directions;\r\n\t}\r\n}\r\n\r\nexport class DragEvent implements StencilEvent {\r\n\ttype: 'drag';\r\n\tnativeEvent: Event;\r\n\tposition: Point;\r\n\tpreviousPosition: Point;\r\n\tanchor: Point;\r\n\telement: HTMLElement;\r\n\r\n\tconstructor(nativeEvent: Event, element: HTMLElement, position: Point, previousPosition: Point, anchor: Point) {\r\n\t\tthis.type = 'drag';\r\n\t\tthis.nativeEvent = nativeEvent;\r\n\t\tthis.position = position;\r\n\t\tthis.previousPosition = previousPosition;\r\n\t\tthis.element = element;\r\n\t\tthis.anchor = anchor;\r\n\t}\r\n\tpublic shift(): Diff {\r\n\t\tconst { element, anchor, position } = this;\r\n\t\tconst { left, top } = element.getBoundingClientRect();\r\n\r\n\t\treturn {\r\n\t\t\tleft: position.left - left - anchor.left,\r\n\t\t\ttop: position.top - top - anchor.top,\r\n\t\t};\r\n\t}\r\n}\r\n","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","<script>\r\nimport draggable from '../../mixins/draggable';\r\n\r\nexport default {\r\n\tname: 'DraggableElement',\r\n\tmixins: [draggable],\r\n\tprops: {\r\n\t\tclassname: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t},\r\n};\r\n</script>\r\n\r\n<template>\r\n\t<div\r\n\t\tref=\"draggable\"\r\n\t\t:class=\"classname\"\r\n\t\t@touchstart=\"onTouchStart\"\r\n\t\t@mousedown=\"onMouseDown\"\r\n\t\t@mouseover=\"onMouseOver\"\r\n\t\t@mouseleave=\"onMouseLeave\"\r\n\t>\r\n\t\t<slot />\r\n\t</div>\r\n</template>\r\n","import { DragEvent } from '../core/events';\r\n\r\nexport default {\r\n\tbeforeMount() {\r\n\t\twindow.addEventListener('mouseup', this.onMouseUp, { passive: false });\r\n\t\twindow.addEventListener('mousemove', this.onMouseMove, { passive: false });\r\n\t\twindow.addEventListener('touchmove', this.onTouchMove, { passive: false });\r\n\t\twindow.addEventListener('touchend', this.onTouchEnd, { passive: false });\r\n\t},\r\n\tbeforeDestroy() {\r\n\t\twindow.removeEventListener('mouseup', this.onMouseUp);\r\n\t\twindow.removeEventListener('mousemove', this.onMouseMove);\r\n\t\twindow.removeEventListener('touchmove', this.onTouchMove);\r\n\t\twindow.removeEventListener('touchend', this.onTouchEnd);\r\n\t},\r\n\tmounted() {\r\n\t\tif (!this.$refs.draggable) {\r\n\t\t\tthrow new Error('You should add ref \"draggable\" to your root element to use draggable mixin');\r\n\t\t}\r\n\t\tthis.touches = [];\r\n\t\tthis.hovered = false;\r\n\t},\r\n\tmethods: {\r\n\t\tonMouseOver() {\r\n\t\t\tif (!this.hovered) {\r\n\t\t\t\tthis.hovered = true;\r\n\t\t\t\tthis.$emit('enter');\r\n\t\t\t}\r\n\t\t},\r\n\t\tonMouseLeave() {\r\n\t\t\tif (this.hovered && !this.touches.length) {\r\n\t\t\t\tthis.hovered = false;\r\n\t\t\t\tthis.$emit('leave');\r\n\t\t\t}\r\n\t\t},\r\n\t\tonTouchStart(e) {\r\n\t\t\tif (e.cancelable && !this.disabled && e.touches.length === 1) {\r\n\t\t\t\tthis.touches = [...e.touches];\r\n\r\n\t\t\t\tif (!this.hovered) {\r\n\t\t\t\t\tthis.$emit('enter');\r\n\t\t\t\t\tthis.hovered = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (e.touches.length) {\r\n\t\t\t\t\tthis.initAnchor(\r\n\t\t\t\t\t\tthis.touches.reduce(\r\n\t\t\t\t\t\t\t(mean, touch) => {\r\n\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\tclientX: mean.clientX + touch.clientX / e.touches.length,\r\n\t\t\t\t\t\t\t\t\tclientY: mean.clientY + touch.clientY / e.touches.length,\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t{ clientX: 0, clientY: 0 },\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tif (e.preventDefault) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t\te.stopPropagation();\r\n\t\t\t}\r\n\t\t},\r\n\t\tonTouchEnd() {\r\n\t\t\tthis.processEnd();\r\n\t\t},\r\n\t\tonTouchMove(e) {\r\n\t\t\tif (this.touches.length) {\r\n\t\t\t\tthis.processMove(e, e.touches);\r\n\t\t\t\tif (e.preventDefault) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t\tif (e.stopPropagation) {\r\n\t\t\t\t\te.stopPropagation();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tonMouseDown(e) {\r\n\t\t\tif (!this.disabled) {\r\n\t\t\t\tconst touch = {\r\n\t\t\t\t\tfake: true,\r\n\t\t\t\t\tclientX: e.clientX,\r\n\t\t\t\t\tclientY: e.clientY,\r\n\t\t\t\t};\r\n\t\t\t\tthis.touches = [touch];\r\n\t\t\t\tthis.initAnchor(touch);\r\n\t\t\t\te.stopPropagation();\r\n\t\t\t}\r\n\t\t},\r\n\t\tonMouseMove(e) {\r\n\t\t\tif (this.touches.length) {\r\n\t\t\t\tthis.processMove(e, [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfake: true,\r\n\t\t\t\t\t\tclientX: e.clientX,\r\n\t\t\t\t\t\tclientY: e.clientY,\r\n\t\t\t\t\t},\r\n\t\t\t\t]);\r\n\t\t\t\tif (e.preventDefault) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tonMouseUp() {\r\n\t\t\tthis.processEnd();\r\n\t\t},\r\n\t\tinitAnchor(touch) {\r\n\t\t\tconst draggable = this.$refs.draggable;\r\n\t\t\tconst { left, right, bottom, top } = draggable.getBoundingClientRect();\r\n\r\n\t\t\tthis.anchor = {\r\n\t\t\t\tleft: touch.clientX - left,\r\n\t\t\t\ttop: touch.clientY - top,\r\n\t\t\t\tbottom: bottom - touch.clientY,\r\n\t\t\t\tright: right - touch.clientX,\r\n\t\t\t};\r\n\t\t},\r\n\t\tprocessMove(event, touches) {\r\n\t\t\tconst newTouches = [...touches];\r\n\t\t\tif (this.touches.length) {\r\n\t\t\t\tif (this.touches.length === 1 && newTouches.length === 1) {\r\n\t\t\t\t\tconst element = this.$refs.draggable;\r\n\t\t\t\t\tthis.$emit(\r\n\t\t\t\t\t\t'drag',\r\n\t\t\t\t\t\tnew DragEvent(\r\n\t\t\t\t\t\t\tevent,\r\n\t\t\t\t\t\t\telement,\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tleft: newTouches[0].clientX,\r\n\t\t\t\t\t\t\t\ttop: newTouches[0].clientY,\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tleft: this.touches[0].clientX,\r\n\t\t\t\t\t\t\t\ttop: this.touches[0].clientY,\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tthis.anchor,\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tthis.touches = newTouches;\r\n\t\t\t}\r\n\t\t},\r\n\t\tprocessEnd() {\r\n\t\t\tif (this.touches.length) {\r\n\t\t\t\tthis.$emit('drag-end');\r\n\t\t\t}\r\n\t\t\tif (this.hovered) {\r\n\t\t\t\tthis.$emit('leave');\r\n\t\t\t\tthis.hovered = false;\r\n\t\t\t}\r\n\t\t\tthis.touches = [];\r\n\t\t},\r\n\t},\r\n};\r\n","import { HorizontalDirection, PositionDirection, VerticalDirection, MainDirections } from './typings';\r\n\r\nexport const ALL_DIRECTIONS: PositionDirection[] = ['left', 'right', 'top', 'bottom'];\r\nexport const HORIZONTAL_DIRECTIONS: HorizontalDirection[] = ['left', 'right'];\r\nexport const VERTICAL_DIRECTIONS: VerticalDirection[] = ['top', 'bottom'];\r\nexport const MAIN_DIRECTIONS: MainDirections[] = ['left', 'top'];\r\nexport const IMAGE_RESTRICTIONS = ['fill-area', 'fit-area', 'stencil', 'none'];\r\nexport const XHR_DONE = 4;\r\n\r\nexport const DEFAULT_COORDINATES = {\r\n\tleft: 0,\r\n\ttop: 0,\r\n\twidth: 0,\r\n\theight: 0,\r\n};\r\n","import {\r\n\tAspectRatio,\r\n\tCoordinates,\r\n\tDiff,\r\n\tIntersections,\r\n\tLimits,\r\n\tMoveDirections,\r\n\tPoint,\r\n\tResizeDirections,\r\n\tSize,\r\n\tSizeRestrictions,\r\n} from './typings';\r\nimport { ALL_DIRECTIONS } from './constants';\r\n\r\nexport function isEqual(a: any, b: any, properties?: string[]): boolean {\r\n\tproperties = properties || ['width', 'height', 'left', 'top'];\r\n\treturn !properties.some((property) => a[property] !== b[property]);\r\n}\r\n\r\nexport function toLimits(object: Coordinates): Limits {\r\n\treturn {\r\n\t\tleft: object.left,\r\n\t\ttop: object.top,\r\n\t\tright: object.left + object.width,\r\n\t\tbottom: object.top + object.height,\r\n\t};\r\n}\r\n\r\nexport function diff(firstObject: Point, secondObject: Point): Diff {\r\n\treturn {\r\n\t\tleft: firstObject.left - secondObject.left,\r\n\t\ttop: firstObject.top - secondObject.top,\r\n\t};\r\n}\r\n\r\nexport function getCenter(object: Coordinates): Point {\r\n\treturn {\r\n\t\tleft: object.left + object.width / 2,\r\n\t\ttop: object.top + object.height / 2,\r\n\t};\r\n}\r\n\r\nexport function getIntersections(object: Coordinates, limits: Limits): Intersections {\r\n\tconst intersections: Intersections = {\r\n\t\tleft: 0,\r\n\t\ttop: 0,\r\n\t\tright: 0,\r\n\t\tbottom: 0,\r\n\t};\r\n\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\tconst areaLimit = limits[direction];\r\n\t\tconst objectLimit = toLimits(object)[direction];\r\n\t\tif (areaLimit !== undefined && objectLimit !== undefined) {\r\n\t\t\tif (direction === 'left' || direction === 'top') {\r\n\t\t\t\tintersections[direction] = Math.max(0, areaLimit - objectLimit);\r\n\t\t\t} else {\r\n\t\t\t\tintersections[direction] = Math.max(0, objectLimit - areaLimit);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tintersections[direction] = 0;\r\n\t\t}\r\n\t});\r\n\treturn intersections;\r\n}\r\n\r\nexport function applyDirections(coordinates: Coordinates, directions: ResizeDirections): Coordinates {\r\n\treturn {\r\n\t\tleft: coordinates.left - directions.left,\r\n\t\ttop: coordinates.top - directions.top,\r\n\t\twidth: coordinates.width + directions.left + directions.right,\r\n\t\theight: coordinates.height + directions.top + directions.bottom,\r\n\t};\r\n}\r\n\r\nexport function inverseMove(directions: MoveDirections): MoveDirections {\r\n\treturn {\r\n\t\tleft: -directions.left,\r\n\t\ttop: -directions.top,\r\n\t};\r\n}\r\n\r\nexport function applyMove(object: Coordinates, move: MoveDirections): Coordinates {\r\n\treturn {\r\n\t\t...object,\r\n\t\tleft: object.left + move.left,\r\n\t\ttop: object.top + move.top,\r\n\t};\r\n}\r\n\r\nexport function applyScale(object: Coordinates, scaleFactor: number, center?: Point, progress?: number): Coordinates {\r\n\tif (scaleFactor !== 1) {\r\n\t\tif (center) {\r\n\t\t\tconst currentCenter = getCenter(object);\r\n\t\t\treturn {\r\n\t\t\t\twidth: object.width * scaleFactor,\r\n\t\t\t\theight: object.height * scaleFactor,\r\n\t\t\t\tleft:\r\n\t\t\t\t\tobject.left +\r\n\t\t\t\t\t(object.width * (1 - scaleFactor)) / 2 +\r\n\t\t\t\t\t(center.left - currentCenter.left) * (progress || 1 - scaleFactor),\r\n\t\t\t\ttop:\r\n\t\t\t\t\tobject.top +\r\n\t\t\t\t\t(object.height * (1 - scaleFactor)) / 2 +\r\n\t\t\t\t\t(center.top - currentCenter.top) * (progress || 1 - scaleFactor),\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\twidth: object.width * scaleFactor,\r\n\t\t\t\theight: object.height * scaleFactor,\r\n\t\t\t\tleft: object.left + (object.width * (1 - scaleFactor)) / 2,\r\n\t\t\t\ttop: object.top + (object.height * (1 - scaleFactor)) / 2,\r\n\t\t\t};\r\n\t\t}\r\n\t} else {\r\n\t\treturn object;\r\n\t}\r\n}\r\n\r\nexport function ratio(object: Size): number {\r\n\treturn object.width / object.height;\r\n}\r\n\r\nexport function maxScale(object: Coordinates, area: Limits): number {\r\n\treturn Math.min(\r\n\t\tarea.right !== undefined && area.left !== undefined ? (area.right - area.left) / object.width : Infinity,\r\n\t\tarea.bottom !== undefined && area.top !== undefined ? (area.bottom - area.top) / object.height : Infinity,\r\n\t);\r\n}\r\n\r\n// Move object to correspond limits\r\nexport function fit(object: Coordinates, limits: Limits): MoveDirections {\r\n\tconst directions = {\r\n\t\tleft: 0,\r\n\t\ttop: 0,\r\n\t};\r\n\r\n\tconst intersection = getIntersections(object, limits);\r\n\r\n\tif (intersection.left && intersection.left > 0) {\r\n\t\tdirections.left = intersection.left;\r\n\t} else if (intersection.right && intersection.right > 0) {\r\n\t\tdirections.left = -intersection.right;\r\n\t}\r\n\tif (intersection.top && intersection.top > 0) {\r\n\t\tdirections.top = intersection.top;\r\n\t} else if (intersection.bottom && intersection.bottom > 0) {\r\n\t\tdirections.top = -intersection.bottom;\r\n\t}\r\n\r\n\treturn directions;\r\n}\r\n\r\nexport function getBrokenRatio(currentAspectRatio: number, aspectRatio: AspectRatio): number | undefined {\r\n\tlet ratioBroken;\r\n\tif (aspectRatio.minimum && currentAspectRatio < aspectRatio.minimum) {\r\n\t\tratioBroken = aspectRatio.minimum;\r\n\t} else if (aspectRatio.maximum && currentAspectRatio > aspectRatio.maximum) {\r\n\t\tratioBroken = aspectRatio.maximum;\r\n\t}\r\n\treturn ratioBroken;\r\n}\r\n\r\nexport function fitSize(firstSize: Size, secondSize: Size): Size {\r\n\tconst firstRatio = ratio(firstSize);\r\n\tconst secondRatio = ratio(secondSize);\r\n\r\n\tif (secondSize.width < Infinity && secondSize.height < Infinity) {\r\n\t\tif (firstRatio > secondRatio) {\r\n\t\t\treturn {\r\n\t\t\t\twidth: secondSize.width,\r\n\t\t\t\theight: secondSize.width / firstRatio,\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\twidth: secondSize.height * firstRatio,\r\n\t\t\t\theight: secondSize.height,\r\n\t\t\t};\r\n\t\t}\r\n\t} else if (secondSize.width < Infinity) {\r\n\t\treturn {\r\n\t\t\twidth: secondSize.width,\r\n\t\t\theight: secondSize.width / firstRatio,\r\n\t\t};\r\n\t} else if (secondSize.height < Infinity) {\r\n\t\treturn {\r\n\t\t\twidth: secondSize.height * firstRatio,\r\n\t\t\theight: secondSize.height,\r\n\t\t};\r\n\t} else {\r\n\t\treturn firstSize;\r\n\t}\r\n}\r\n\r\nexport function rotateSize(size: Size, angle: number) {\r\n\tconst radians = (angle * Math.PI) / 180;\r\n\treturn {\r\n\t\twidth: Math.abs(size.width * Math.cos(radians)) + Math.abs(size.height * Math.sin(radians)),\r\n\t\theight: Math.abs(size.width * Math.sin(radians)) + Math.abs(size.height * Math.cos(radians)),\r\n\t};\r\n}\r\n\r\nexport function rotatePoint(point: Point, angle: number) {\r\n\tconst radians = (angle * Math.PI) / 180;\r\n\treturn {\r\n\t\tleft: point.left * Math.cos(radians) - point.top * Math.sin(radians),\r\n\t\ttop: point.left * Math.sin(radians) + point.top * Math.cos(radians),\r\n\t};\r\n}\r\n\r\nexport function adjustSize(coordinates: Coordinates, area: Limits) {\r\n\tconst intersections = getIntersections(fitToLimits(coordinates, area), area);\r\n\r\n\tif (intersections.left + intersections.right + intersections.top + intersections.bottom) {\r\n\t\tif (intersections.left + intersections.right > intersections.top + intersections.bottom) {\r\n\t\t\treturn Math.min(\r\n\t\t\t\t(coordinates.width + intersections.left + intersections.right) / coordinates.width,\r\n\t\t\t\tmaxScale(coordinates, area),\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\treturn Math.min(\r\n\t\t\t\t(coordinates.height + intersections.top + intersections.bottom) / coordinates.height,\r\n\t\t\t\tmaxScale(coordinates, area),\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nexport function fitToLimits(coordinates: Coordinates, area: Limits, inverse = false) {\r\n\tconst move = fit(coordinates, area);\r\n\treturn applyMove(coordinates, inverse ? inverseMove(move) : move);\r\n}\r\n\r\nexport function limitsToSize(area: Limits) {\r\n\treturn {\r\n\t\twidth: area.right !== undefined && area.left !== undefined ? area.right - area.left : Infinity,\r\n\t\theight: area.bottom !== undefined && area.top !== undefined ? area.bottom - area.top : Infinity,\r\n\t};\r\n}\r\n\r\nexport function limitSizeRestrictions(sizeRestrictions: SizeRestrictions, object: Size) {\r\n\treturn {\r\n\t\t...sizeRestrictions,\r\n\t\tminWidth: Math.min(object.width, sizeRestrictions.minWidth),\r\n\t\tminHeight: Math.min(object.height, sizeRestrictions.minHeight),\r\n\t\tmaxWidth: Math.min(object.width, sizeRestrictions.maxWidth),\r\n\t\tmaxHeight: Math.min(object.height, sizeRestrictions.maxHeight),\r\n\t};\r\n}\r\n\r\nexport function joinLimits(a: Limits, b: Limits, intersection = true): Limits {\r\n\tconst limits: Limits = {};\r\n\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\tconst firstDirection = a[direction];\r\n\t\tconst secondDirection = b[direction];\r\n\t\tif (firstDirection !== undefined && secondDirection !== undefined) {\r\n\t\t\tif (direction === 'left' || direction === 'top') {\r\n\t\t\t\tlimits[direction] = intersection\r\n\t\t\t\t\t? Math.max(firstDirection, secondDirection)\r\n\t\t\t\t\t: Math.min(firstDirection, secondDirection);\r\n\t\t\t} else {\r\n\t\t\t\tlimits[direction] = intersection\r\n\t\t\t\t\t? Math.min(firstDirection, secondDirection)\r\n\t\t\t\t\t: Math.max(firstDirection, secondDirection);\r\n\t\t\t}\r\n\t\t} else if (secondDirection !== undefined) {\r\n\t\t\tlimits[direction] = secondDirection;\r\n\t\t} else if (firstDirection !== undefined) {\r\n\t\t\tlimits[direction] = firstDirection;\r\n\t\t}\r\n\t});\r\n\treturn limits;\r\n}\r\n\r\nexport function unionLimits(a: Limits, b: Limits) {\r\n\treturn joinLimits(a, b, false);\r\n}\r\n\r\nexport function intersectionLimits(a: Limits, b: Limits) {\r\n\treturn joinLimits(a, b, true);\r\n}\r\n","// This function returns the approximation size to width / height with respect to\r\n// restrictions and aspect ratio\r\nimport { AspectRatio, Size, SizeRestrictions } from '../typings';\r\nimport { ratio } from '../service';\r\n\r\ninterface CandidateSize extends Size {\r\n\t// Additional param to prevent double precision problems\r\n\tcorrectRatio?: boolean;\r\n}\r\n\r\ninterface ValidateSizeParams {\r\n\tsize: CandidateSize;\r\n\taspectRatio: AspectRatio;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tignoreMinimum?: boolean;\r\n}\r\nfunction validateSize(params: ValidateSizeParams): boolean {\r\n\tconst { size, aspectRatio, ignoreMinimum, sizeRestrictions } = params;\r\n\treturn Boolean(\r\n\t\t(size.correctRatio || (ratio(size) >= aspectRatio.minimum && ratio(size) <= aspectRatio.maximum)) &&\r\n\t\t\tsize.height <= sizeRestrictions.maxHeight &&\r\n\t\t\tsize.width <= sizeRestrictions.maxWidth &&\r\n\t\t\tsize.width &&\r\n\t\t\tsize.height &&\r\n\t\t\t(ignoreMinimum || (size.height >= sizeRestrictions.minHeight && size.width >= sizeRestrictions.minWidth)),\r\n\t);\r\n}\r\n\r\nfunction distance(a: Size, b: Size): number {\r\n\treturn Math.pow(a.width - b.width, 2) + Math.pow(a.height - b.height, 2);\r\n}\r\n\r\n// Limitations:\r\n// 1. Assume that maximum width and height always larger than minimum width and height\r\n// 2. Assume that aspectRatio.minimum < aspectRatio.maximum\r\n// If you break this limitations function could return null!\r\ninterface ApproximatedSizeParams {\r\n\twidth: number;\r\n\theight: number;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\taspectRatio?: AspectRatio;\r\n}\r\nexport function approximatedSize(params: ApproximatedSizeParams): Size {\r\n\tconst { width, height, sizeRestrictions } = params;\r\n\r\n\tconst aspectRatio = {\r\n\t\tminimum: (params.aspectRatio && params.aspectRatio.minimum) || 0,\r\n\t\tmaximum: (params.aspectRatio && params.aspectRatio.maximum) || Infinity,\r\n\t};\r\n\r\n\tconst coordinates = {\r\n\t\twidth: Math.max(sizeRestrictions.minWidth, Math.min(sizeRestrictions.maxWidth, width)),\r\n\t\theight: Math.max(sizeRestrictions.minHeight, Math.min(sizeRestrictions.maxHeight, height)),\r\n\t};\r\n\r\n\tfunction findBestCandidate(candidates: CandidateSize[], ignoreMinimum = false): CandidateSize | null {\r\n\t\treturn candidates.reduce<CandidateSize | null>((minimum: CandidateSize | null, size: CandidateSize) => {\r\n\t\t\tif (validateSize({ size, aspectRatio, sizeRestrictions, ignoreMinimum })) {\r\n\t\t\t\treturn !minimum || distance(size, { width, height }) < distance(minimum, { width, height })\r\n\t\t\t\t\t? size\r\n\t\t\t\t\t: minimum;\r\n\t\t\t} else {\r\n\t\t\t\treturn minimum;\r\n\t\t\t}\r\n\t\t}, null);\r\n\t}\r\n\r\n\tconst candidates: CandidateSize[] = [];\r\n\r\n\tif (aspectRatio) {\r\n\t\t[aspectRatio.minimum, aspectRatio.maximum].forEach((ratio) => {\r\n\t\t\tif (ratio) {\r\n\t\t\t\tcandidates.push(\r\n\t\t\t\t\t{ width: coordinates.width, height: coordinates.width / ratio, correctRatio: true },\r\n\t\t\t\t\t{ width: coordinates.height * ratio, height: coordinates.height, correctRatio: true },\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tif (validateSize({ size: coordinates, aspectRatio, sizeRestrictions })) {\r\n\t\tcandidates.push(coordinates);\r\n\t}\r\n\r\n\tconst candidate = findBestCandidate(candidates) || findBestCandidate(candidates, true);\r\n\r\n\treturn (\r\n\t\tcandidate && {\r\n\t\t\twidth: candidate.width,\r\n\t\t\theight: candidate.height,\r\n\t\t}\r\n\t);\r\n}\r\n","import { MoveEvent } from '../events';\r\nimport { Coordinates, PositionRestrictions } from '../typings';\r\nimport { applyMove, fit } from '../service';\r\n\r\nexport interface MoveParams {\r\n\tevent: MoveEvent;\r\n\tcoordinates: Coordinates;\r\n\tpositionRestrictions: PositionRestrictions;\r\n}\r\n\r\nexport function move(params: MoveParams): Coordinates {\r\n\tconst { event, coordinates, positionRestrictions = {} } = params;\r\n\r\n\tconst movedCoordinates = applyMove(coordinates, event.directions);\r\n\r\n\treturn applyMove(movedCoordinates, fit(movedCoordinates, positionRestrictions));\r\n}\r\n","import {\r\n\tAspectRatio,\r\n\tPositionRestrictions,\r\n\tSizeRestrictions,\r\n\tTransform,\r\n\tCoordinates,\r\n\tSize,\r\n\tVisibleArea,\r\n} from '../typings';\r\nimport { MoveEvent } from '../events';\r\nimport { approximatedSize } from './approximatedSize';\r\nimport { isUndefined } from '../utils';\r\nimport { move } from './move';\r\n\r\ninterface ApplyTransformParams {\r\n\tcoordinates: Coordinates;\r\n\ttransform: Transform | Transform[];\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n\timageSize: Size;\r\n\tvisibleArea: VisibleArea;\r\n\taspectRatio?: AspectRatio;\r\n}\r\n\r\nexport function applyTransform(params: ApplyTransformParams) {\r\n\tconst {\r\n\t\tcoordinates: initialCoordinates,\r\n\t\ttransform,\r\n\t\timageSize,\r\n\t\tsizeRestrictions,\r\n\t\tpositionRestrictions,\r\n\t\taspectRatio,\r\n\t\tvisibleArea,\r\n\t} = params;\r\n\r\n\tconst moveAlgorithm = (prevCoordinates, newCoordinates) => {\r\n\t\treturn move({\r\n\t\t\tcoordinates: prevCoordinates,\r\n\t\t\tpositionRestrictions,\r\n\t\t\tevent: new MoveEvent({\r\n\t\t\t\tleft: newCoordinates.left - prevCoordinates.left,\r\n\t\t\t\ttop: newCoordinates.top - prevCoordinates.top,\r\n\t\t\t}),\r\n\t\t});\r\n\t};\r\n\r\n\tconst resizeAlgorithm = (prevCoordinates, newCoordinates) => {\r\n\t\tlet coordinates = {\r\n\t\t\t...prevCoordinates,\r\n\t\t\t...approximatedSize({\r\n\t\t\t\twidth: newCoordinates.width,\r\n\t\t\t\theight: newCoordinates.height,\r\n\t\t\t\tsizeRestrictions,\r\n\t\t\t\taspectRatio,\r\n\t\t\t}),\r\n\t\t\tleft: 0,\r\n\t\t\ttop: 0,\r\n\t\t};\r\n\r\n\t\treturn moveAlgorithm(coordinates, {\r\n\t\t\tleft: prevCoordinates.left,\r\n\t\t\ttop: prevCoordinates.top,\r\n\t\t});\r\n\t};\r\n\r\n\tlet coordinates = { ...initialCoordinates };\r\n\r\n\tconst transforms = Array.isArray(transform) ? transform : [transform];\r\n\r\n\ttransforms.forEach((transform) => {\r\n\t\tlet changes: Partial<Coordinates> = {};\r\n\t\tif (typeof transform === 'function') {\r\n\t\t\tchanges = transform({ coordinates, imageSize, visibleArea });\r\n\t\t} else {\r\n\t\t\tchanges = transform;\r\n\t\t}\r\n\r\n\t\tif (!isUndefined(changes.width) || !isUndefined(changes.height)) {\r\n\t\t\tcoordinates = resizeAlgorithm(coordinates, { ...coordinates, ...changes });\r\n\t\t}\r\n\t\tif (!isUndefined(changes.left) || !isUndefined(changes.top)) {\r\n\t\t\tcoordinates = moveAlgorithm(coordinates, { ...coordinates, ...changes });\r\n\t\t}\r\n\t});\r\n\r\n\treturn coordinates;\r\n}\r\n","import {\n\tadjustSize,\n\tapplyMove,\n\tapplyScale,\n\tdiff,\n\tfit,\n\tfitToLimits,\n\tgetCenter,\n\tintersectionLimits,\n\tinverseMove,\n\tmaxScale,\n\tratio,\n\ttoLimits,\n} from '../service';\nimport {\n\tAspectRatio,\n\tBoundaries,\n\tCoordinates,\n\tCropperEvent,\n\tGetAreaRestrictions,\n\tPositionRestrictions,\n\tSize,\n\tSizeRestrictions,\n\tVisibleArea,\n} from '../typings';\nimport { isApproximatelyEqual } from '../utils';\nimport { approximatedSize } from './approximatedSize';\nimport { ALL_DIRECTIONS } from '../constants';\n\ninterface AutoZoomResult {\n\tvisibleArea: VisibleArea;\n\tcoordinates: Coordinates;\n}\n\ninterface AutoZoomParams {\n\tevent: CropperEvent;\n\tcoordinates: Coordinates;\n\tstencilReference: Coordinates;\n\tvisibleArea: VisibleArea;\n\tboundaries: Boundaries;\n\taspectRatio: AspectRatio;\n\tstencilSize: Size;\n\tsizeRestrictions: SizeRestrictions;\n\tpositionRestrictions: PositionRestrictions;\n\tgetAreaRestrictions: GetAreaRestrictions;\n}\n\nexport function fixedStencilAutoZoom(params: AutoZoomParams): AutoZoomResult {\n\tconst {\n\t\tevent,\n\t\tgetAreaRestrictions,\n\t\tboundaries,\n\t\tcoordinates: originalCoordinates,\n\t\tvisibleArea: originalVisibleArea,\n\t\taspectRatio,\n\t\tstencilSize,\n\t\tsizeRestrictions,\n\t\tpositionRestrictions,\n\t\tstencilReference,\n\t} = params;\n\n\tlet coordinates = { ...originalCoordinates };\n\tlet visibleArea = { ...originalVisibleArea };\n\n\t// Checks that coordinates has the same ratio that coordinates:\n\tlet stencil = { ...stencilSize };\n\n\tif (!isApproximatelyEqual(ratio(stencil), ratio(coordinates))) {\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tconsole.error(\n\t\t\t\t`[Adjusting stencil] The aspect ratio of coordinates is not equal to the aspect ratio of stencil (${ratio(\n\t\t\t\t\tcoordinates,\n\t\t\t\t)} != ${ratio(stencil)})! Coordinates will be changed`,\n\t\t\t);\n\t\t}\n\t\tcoordinates = {\n\t\t\t...coordinates,\n\t\t\t...approximatedSize({\n\t\t\t\tsizeRestrictions,\n\t\t\t\twidth: coordinates.width,\n\t\t\t\theight: coordinates.height,\n\t\t\t\taspectRatio: {\n\t\t\t\t\tminimum: ratio(stencil),\n\t\t\t\t\tmaximum: ratio(stencil),\n\t\t\t\t},\n\t\t\t}),\n\t\t};\n\t}\n\n\t// First of all try to resize visible area as much as possible:\n\tvisibleArea = applyScale(visibleArea, (coordinates.width * boundaries.width) / (visibleArea.width * stencil.width));\n\n\t// Check that visible area doesn't break the area restrictions:\n\tconst scale = adjustSize(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' }));\n\tif (scale !== 1) {\n\t\tvisibleArea = applyScale(visibleArea, scale);\n\t\tcoordinates = applyScale(coordinates, scale);\n\t}\n\n\tvisibleArea = applyMove(visibleArea, diff(getCenter(coordinates), getCenter(visibleArea)));\n\n\t// Center stencil in visible area:\n\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\n\tcoordinates = fitToLimits(coordinates, intersectionLimits(toLimits(visibleArea), positionRestrictions));\n\n\treturn {\n\t\tcoordinates,\n\t\tvisibleArea,\n\t};\n}\n\nexport function hybridStencilAutoZoom(params: AutoZoomParams): AutoZoomResult {\n\tconst {\n\t\tevent,\n\t\tgetAreaRestrictions,\n\t\tboundaries,\n\t\tcoordinates: originalCoordinates,\n\t\tvisibleArea: originalVisibleArea,\n\t\taspectRatio,\n\t\tstencilSize,\n\t\tsizeRestrictions,\n\t\tpositionRestrictions,\n\t\tstencilReference,\n\t} = params;\n\n\tlet coordinates = { ...originalCoordinates };\n\tlet visibleArea = { ...originalVisibleArea };\n\n\tif (originalCoordinates && originalVisibleArea && event.type !== 'manipulateImage') {\n\t\t// Checks that coordinates has the same ratio that coordinates:\n\t\tlet stencil: Size = {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t};\n\n\t\tconst coefficient = visibleArea.width / boundaries.width;\n\n\t\tif (ratio(boundaries) > ratio(coordinates)) {\n\t\t\tstencil.height = boundaries.height * 0.8;\n\t\t\tstencil.width = stencil.height * ratio(coordinates);\n\t\t} else {\n\t\t\tstencil.width = boundaries.width * 0.8;\n\t\t\tstencil.height = stencil.width * ratio(coordinates);\n\t\t}\n\n\t\t// First of all try to resize visible area as much as possible:\n\t\tvisibleArea = applyScale(\n\t\t\tvisibleArea,\n\t\t\t(coordinates.width * boundaries.width) / (visibleArea.width * stencil.width),\n\t\t);\n\n\t\t// Check that visible area doesn't break the area restrictions:\n\t\tconst scale = adjustSize(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' }));\n\t\tvisibleArea = applyScale(visibleArea, scale);\n\n\t\tif (scale !== 1) {\n\t\t\tstencil.height /= scale;\n\t\t\tstencil.width /= scale;\n\t\t}\n\n\t\tvisibleArea = applyMove(visibleArea, diff(getCenter(coordinates), getCenter(visibleArea)));\n\n\t\t// Center stencil in visible area:\n\t\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\n\t\tcoordinates = fitToLimits(coordinates, intersectionLimits(toLimits(visibleArea), positionRestrictions));\n\t}\n\n\treturn {\n\t\tcoordinates,\n\t\tvisibleArea,\n\t};\n}\n\n// The main point of this feature is calculating the needed position of stencil and parameters of world transforms\n// Real coordinates don't changes here\ninterface SimplestAutoZoomParams {\n\tevent: CropperEvent;\n\tcoordinates: Coordinates;\n\tvisibleArea: VisibleArea;\n\tgetAreaRestrictions: GetAreaRestrictions;\n}\nexport function simplestAutoZoom(params: SimplestAutoZoomParams): AutoZoomResult {\n\tconst { event, coordinates: originalCoordinates, visibleArea: originalVisibleArea, getAreaRestrictions } = params;\n\n\tlet visibleArea = { ...originalVisibleArea };\n\tconst coordinates = { ...originalCoordinates };\n\n\tif (event.type === 'setCoordinates') {\n\t\tconst widthIntersections = Math.max(0, coordinates.width - visibleArea.width);\n\t\tconst heightIntersections = Math.max(0, coordinates.height - visibleArea.height);\n\n\t\tif (widthIntersections > heightIntersections) {\n\t\t\tvisibleArea = applyScale(\n\t\t\t\tvisibleArea,\n\t\t\t\tMath.min(\n\t\t\t\t\tcoordinates.width / visibleArea.width,\n\t\t\t\t\tmaxScale(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' })),\n\t\t\t\t),\n\t\t\t);\n\t\t} else if (heightIntersections > widthIntersections) {\n\t\t\tvisibleArea = applyScale(\n\t\t\t\tvisibleArea,\n\t\t\t\tMath.min(\n\t\t\t\t\tcoordinates.height / visibleArea.height,\n\t\t\t\t\tmaxScale(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' })),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tvisibleArea = applyMove(visibleArea, inverseMove(fit(coordinates, toLimits(visibleArea))));\n\n\t\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\n\t}\n\treturn {\n\t\tvisibleArea,\n\t\tcoordinates,\n\t};\n}\n","import {\r\n\tAspectRatio,\r\n\tBoundaries,\r\n\tFalsy,\r\n\tImageSize,\r\n\tSize,\r\n\tSizeRestrictions,\r\n\tStencilSize,\r\n\tVisibleArea,\r\n} from '../typings';\r\nimport { approximatedSize } from './approximatedSize';\r\nimport { ratio } from '../service';\r\nimport { isNumber } from '../utils';\r\n\r\ninterface DefaultSizeBasicParams {\r\n\taspectRatio: AspectRatio;\r\n\tboundaries: Boundaries;\r\n\tsizeRestrictions: SizeRestrictions;\r\n}\r\n\r\ninterface ImageDefaultSizeParams extends DefaultSizeBasicParams {\r\n\timageSize: ImageSize;\r\n\tvisibleArea?: VisibleArea | Falsy;\r\n}\r\n\r\ninterface VisibleAreaDefaultSizeParams extends DefaultSizeBasicParams {\r\n\timageSize?: ImageSize | Falsy;\r\n\tvisibleArea: VisibleArea;\r\n}\r\n\r\nexport type DefaultSizeParams = VisibleAreaDefaultSizeParams | ImageDefaultSizeParams;\r\n\r\nexport function defaultSize(params: DefaultSizeParams): Size {\r\n\tconst { imageSize, visibleArea, aspectRatio, sizeRestrictions } = params;\r\n\r\n\tconst area = (visibleArea || imageSize) as Size;\r\n\r\n\tconst optimalRatio = Math.min(aspectRatio.maximum || Infinity, Math.max(aspectRatio.minimum || 0, ratio(area)));\r\n\r\n\tconst size =\r\n\t\tarea.width < area.height\r\n\t\t\t? {\r\n\t\t\t\t\twidth: area.width * 0.8,\r\n\t\t\t\t\theight: (area.width * 0.8) / optimalRatio,\r\n\t\t\t  }\r\n\t\t\t: {\r\n\t\t\t\t\theight: area.height * 0.8,\r\n\t\t\t\t\twidth: area.height * 0.8 * optimalRatio,\r\n\t\t\t  };\r\n\r\n\treturn approximatedSize({\r\n\t\t...size,\r\n\t\taspectRatio,\r\n\t\tsizeRestrictions: sizeRestrictions,\r\n\t});\r\n}\r\n\r\nexport type FixedDefaultSizeParams = DefaultSizeParams & { stencilSize: Size };\r\n\r\nexport function fixedDefaultSize(params: FixedDefaultSizeParams): Size {\r\n\tconst { imageSize, visibleArea, boundaries, aspectRatio, sizeRestrictions, stencilSize } = params;\r\n\r\n\tconst area = (visibleArea || imageSize) as Size;\r\n\r\n\tlet height, width;\r\n\tif (ratio(area) > ratio(boundaries)) {\r\n\t\theight = (stencilSize.height * area.height) / boundaries.height;\r\n\t\twidth = height * ratio(stencilSize);\r\n\t} else {\r\n\t\twidth = (stencilSize.width * area.width) / boundaries.width;\r\n\t\theight = width / ratio(stencilSize);\r\n\t}\r\n\r\n\treturn approximatedSize({\r\n\t\twidth,\r\n\t\theight,\r\n\t\taspectRatio,\r\n\t\tsizeRestrictions: sizeRestrictions,\r\n\t});\r\n}\r\n","import { Coordinates, Limits } from '../typings';\r\nimport { joinLimits } from '../service';\r\nimport { toLimits } from '../service';\r\n\r\nexport function limitBy(limits: Limits, object: Coordinates): Limits {\r\n\treturn joinLimits(limits, toLimits(object));\r\n}\r\n","import { ManipulateImageEvent } from '../events';\r\nimport { GetAreaRestrictions, Coordinates, PositionRestrictions, SizeRestrictions, VisibleArea } from '../typings';\r\nimport {\r\n\tapplyMove,\r\n\tapplyScale,\r\n\tfit,\r\n\tfitToLimits,\r\n\tgetCenter,\r\n\tintersectionLimits,\r\n\tinverseMove,\r\n\tmaxScale,\r\n\ttoLimits,\r\n} from '../service';\r\n\r\ninterface ManipulateImageParams {\r\n\tevent: ManipulateImageEvent;\r\n\tcoordinates: Coordinates;\r\n\tvisibleArea: VisibleArea;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n\tadjustStencil: boolean;\r\n}\r\ninterface ManipulateImageResult {\r\n\tvisibleArea: VisibleArea;\r\n\tcoordinates: Coordinates;\r\n}\r\nexport function manipulateImage(params: ManipulateImageParams): ManipulateImageResult {\r\n\tconst {\r\n\t\tevent,\r\n\t\tcoordinates: originalCoordinates,\r\n\t\tvisibleArea: originalVisibleArea,\r\n\t\tsizeRestrictions,\r\n\t\tgetAreaRestrictions,\r\n\t\tpositionRestrictions,\r\n\t\tadjustStencil,\r\n\t} = params;\r\n\r\n\tconst { scale, move } = event;\r\n\r\n\tlet visibleArea = { ...originalVisibleArea };\r\n\tlet coordinates = { ...originalCoordinates };\r\n\r\n\tlet areaScale = 1;\r\n\tlet stencilScale = 1;\r\n\tconst allowedScale = scale.factor && Math.abs(scale.factor - 1) > 1e-3;\r\n\r\n\tvisibleArea = applyMove(visibleArea, {\r\n\t\tleft: move.left || 0,\r\n\t\ttop: move.top || 0,\r\n\t});\r\n\r\n\tconst scaleRestrictions = {\r\n\t\tstencil: {\r\n\t\t\tminimum: Math.max(\r\n\t\t\t\tsizeRestrictions.minWidth ? sizeRestrictions.minWidth / coordinates.width : 0,\r\n\t\t\t\tsizeRestrictions.minHeight ? sizeRestrictions.minHeight / coordinates.height : 0,\r\n\t\t\t),\r\n\t\t\tmaximum: Math.min(\r\n\t\t\t\tsizeRestrictions.maxWidth ? sizeRestrictions.maxWidth / coordinates.width : Infinity,\r\n\t\t\t\tsizeRestrictions.maxHeight ? sizeRestrictions.maxHeight / coordinates.height : Infinity,\r\n\t\t\t\tmaxScale(coordinates, positionRestrictions),\r\n\t\t\t),\r\n\t\t},\r\n\t\tarea: {\r\n\t\t\tmaximum: maxScale(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' })),\r\n\t\t},\r\n\t};\r\n\r\n\t// If there is scaling then begin scale\r\n\tif (scale.factor && allowedScale) {\r\n\t\t// Determine scale factor\r\n\t\tif (scale.factor < 1) {\r\n\t\t\tstencilScale = Math.max(scale.factor, scaleRestrictions.stencil.minimum);\r\n\t\t\tif (stencilScale > 1) {\r\n\t\t\t\tstencilScale = 1;\r\n\t\t\t}\r\n\t\t} else if (scale.factor > 1) {\r\n\t\t\tstencilScale = Math.min(\r\n\t\t\t\tscale.factor,\r\n\t\t\t\tMath.min(scaleRestrictions.area.maximum, scaleRestrictions.stencil.maximum),\r\n\t\t\t);\r\n\t\t\tif (stencilScale < 1) {\r\n\t\t\t\tstencilScale = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (stencilScale) {\r\n\t\t// Resize stencil with area as much is possible\r\n\t\tvisibleArea = applyScale(visibleArea, stencilScale, scale.center);\r\n\t}\r\n\r\n\tconst relativeCoordinates = {\r\n\t\tleft: originalCoordinates.left - originalVisibleArea.left,\r\n\t\tright:\r\n\t\t\toriginalVisibleArea.width +\r\n\t\t\toriginalVisibleArea.left -\r\n\t\t\t(originalCoordinates.width + originalCoordinates.left),\r\n\t\ttop: originalCoordinates.top - originalVisibleArea.top,\r\n\t\tbottom:\r\n\t\t\toriginalVisibleArea.height +\r\n\t\t\toriginalVisibleArea.top -\r\n\t\t\t(originalCoordinates.height + originalCoordinates.top),\r\n\t};\r\n\r\n\t// Move the area to fit to coordinates limits:\r\n\tvisibleArea = applyMove(\r\n\t\tvisibleArea,\r\n\t\tfit(visibleArea, {\r\n\t\t\tleft:\r\n\t\t\t\tpositionRestrictions.left !== undefined\r\n\t\t\t\t\t? positionRestrictions.left - relativeCoordinates.left * stencilScale\r\n\t\t\t\t\t: undefined,\r\n\t\t\ttop:\r\n\t\t\t\tpositionRestrictions.top !== undefined\r\n\t\t\t\t\t? positionRestrictions.top - relativeCoordinates.top * stencilScale\r\n\t\t\t\t\t: undefined,\r\n\t\t\tbottom:\r\n\t\t\t\tpositionRestrictions.bottom !== undefined\r\n\t\t\t\t\t? positionRestrictions.bottom + relativeCoordinates.bottom * stencilScale\r\n\t\t\t\t\t: undefined,\r\n\t\t\tright:\r\n\t\t\t\tpositionRestrictions.right !== undefined\r\n\t\t\t\t\t? positionRestrictions.right + relativeCoordinates.right * stencilScale\r\n\t\t\t\t\t: undefined,\r\n\t\t}),\r\n\t);\r\n\r\n\t// But the more important to fit are to the area restrictions, so we should fit it to that restrictions:\r\n\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\r\n\t// Set the same coordinates of stencil inside visible area\r\n\tcoordinates.width = coordinates.width * stencilScale;\r\n\tcoordinates.height = coordinates.height * stencilScale;\r\n\tcoordinates.left = visibleArea.left + relativeCoordinates.left * stencilScale;\r\n\tcoordinates.top = visibleArea.top + relativeCoordinates.top * stencilScale;\r\n\r\n\t// Move the coordinates to prevent the intersection with visible area and position restrictions\r\n\tcoordinates = fitToLimits(coordinates, intersectionLimits(toLimits(visibleArea), positionRestrictions));\r\n\r\n\t// Resize only area if stencil can't be resized and stencil resize is disabled\r\n\tif (scale.factor && allowedScale && adjustStencil) {\r\n\t\tif (scale.factor > 1) {\r\n\t\t\tareaScale = Math.min(scaleRestrictions.area.maximum, scale.factor) / stencilScale;\r\n\t\t} else if (scale.factor < 1) {\r\n\t\t\tareaScale = Math.max(coordinates.height / visibleArea.height, scale.factor / stencilScale);\r\n\t\t}\r\n\t\tif (areaScale !== 1) {\r\n\t\t\tvisibleArea = applyScale(visibleArea, areaScale, scale.factor > 1 ? scale.center : getCenter(coordinates));\r\n\r\n\t\t\t// Move to prevent the breaking of the area restrictions:\r\n\t\t\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\r\n\t\t\t// Move to prevent the intersection with coordinates:\r\n\t\t\tvisibleArea = applyMove(visibleArea, inverseMove(fit(coordinates, toLimits(visibleArea))));\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcoordinates,\r\n\t\tvisibleArea,\r\n\t};\r\n}\r\n","import {\r\n\tAspectRatio,\r\n\tBoundaries,\r\n\tCoordinates,\r\n\tCropperEvent,\r\n\tGetAreaRestrictions,\r\n\tImageSize,\r\n\tPositionRestrictions,\r\n\tSize,\r\n\tSizeRestrictions,\r\n\tVisibleArea,\r\n} from '../typings';\r\nimport { isApproximatelyEqual, sign } from '../utils';\r\nimport {\r\n\tadjustSize,\r\n\tapplyMove,\r\n\tapplyScale,\r\n\tdiff,\r\n\tfitSize,\r\n\tfitToLimits,\r\n\tgetCenter,\r\n\tintersectionLimits,\r\n\tratio,\r\n\trotatePoint,\r\n\trotateSize,\r\n\ttoLimits,\r\n} from '../service';\r\nimport { approximatedSize } from './approximatedSize';\r\n\r\ninterface RotateImageParams {\r\n\taspectRatio: AspectRatio;\r\n\tcoordinates: Coordinates;\r\n\tvisibleArea: VisibleArea;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n\timageSize: ImageSize;\r\n\tpreviousImageSize: ImageSize;\r\n\tangle: number;\r\n}\r\n\r\ninterface RotateImageResult {\r\n\tvisibleArea: VisibleArea;\r\n\tcoordinates: Coordinates;\r\n}\r\n\r\nexport function rotateImage(params: RotateImageParams): RotateImageResult {\r\n\tconst {\r\n\t\taspectRatio,\r\n\t\tgetAreaRestrictions,\r\n\t\tcoordinates: originalCoordinates,\r\n\t\tvisibleArea: originalVisibleArea,\r\n\t\tsizeRestrictions,\r\n\t\tpositionRestrictions,\r\n\t\timageSize,\r\n\t\tpreviousImageSize,\r\n\t\tangle,\r\n\t} = params;\r\n\r\n\tlet coordinates = { ...originalCoordinates };\r\n\tlet visibleArea = { ...originalVisibleArea };\r\n\r\n\tconst imageCenter = rotatePoint(\r\n\t\tgetCenter({\r\n\t\t\tleft: 0,\r\n\t\t\ttop: 0,\r\n\t\t\t...previousImageSize,\r\n\t\t}),\r\n\t\tangle,\r\n\t);\r\n\r\n\tcoordinates = {\r\n\t\t...approximatedSize({\r\n\t\t\tsizeRestrictions,\r\n\t\t\taspectRatio,\r\n\t\t\twidth: coordinates.width,\r\n\t\t\theight: coordinates.height,\r\n\t\t}),\r\n\t\t...rotatePoint(getCenter(coordinates), angle),\r\n\t};\r\n\r\n\tcoordinates.left -= imageCenter.left - imageSize.width / 2 + coordinates.width / 2;\r\n\tcoordinates.top -= imageCenter.top - imageSize.height / 2 + coordinates.height / 2;\r\n\r\n\t// Check that visible area doesn't break the area restrictions:\r\n\tvisibleArea = applyScale(\r\n\t\tvisibleArea,\r\n\t\tadjustSize(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' })),\r\n\t);\r\n\r\n\tcoordinates = fitToLimits(coordinates, positionRestrictions);\r\n\r\n\tvisibleArea = applyMove(visibleArea, diff(getCenter(coordinates), getCenter(originalCoordinates)));\r\n\r\n\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\r\n\treturn {\r\n\t\tcoordinates,\r\n\t\tvisibleArea,\r\n\t};\r\n}\r\n","import {\r\n\tAspectRatio,\r\n\tBoundaries,\r\n\tCoordinates,\r\n\tCropperEvent,\r\n\tGetAreaRestrictions,\r\n\tImageSize,\r\n\tPositionRestrictions,\r\n\tSize,\r\n\tSizeRestrictions,\r\n\tVisibleArea,\r\n} from '../typings';\r\nimport { isApproximatelyEqual, sign } from '../utils';\r\nimport {\r\n\tadjustSize,\r\n\tapplyMove,\r\n\tapplyScale,\r\n\tdiff,\r\n\tfitSize,\r\n\tfitToLimits,\r\n\tgetCenter,\r\n\tintersectionLimits,\r\n\tratio,\r\n\trotatePoint,\r\n\trotateSize,\r\n\ttoLimits,\r\n} from '../service';\r\nimport { approximatedSize } from './approximatedSize';\r\n\r\ninterface Reflect {\r\n\thorizontal: boolean;\r\n\tvertical: boolean;\r\n}\r\n\r\ninterface FlipImageParams {\r\n\taspectRatio: AspectRatio;\r\n\tcoordinates: Coordinates;\r\n\tvisibleArea: VisibleArea;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n\timageSize: ImageSize;\r\n\tpreviousFlip: Reflect;\r\n\tflip: Reflect;\r\n\trotate: number;\r\n}\r\n\r\ninterface FlipImageResult {\r\n\tvisibleArea: VisibleArea;\r\n\tcoordinates: Coordinates;\r\n}\r\n\r\nexport function flipImage(params: FlipImageParams): FlipImageResult {\r\n\tconst {\r\n\t\tflip,\r\n\t\tpreviousFlip,\r\n\t\trotate,\r\n\t\taspectRatio,\r\n\t\tgetAreaRestrictions,\r\n\t\tcoordinates: originalCoordinates,\r\n\t\tvisibleArea: originalVisibleArea,\r\n\t\timageSize,\r\n\t} = params;\r\n\r\n\tlet coordinates = { ...originalCoordinates };\r\n\tlet visibleArea = { ...originalVisibleArea };\r\n\r\n\tconst changed = {\r\n\t\thorizontal: previousFlip.horizontal !== flip.horizontal,\r\n\t\tvertical: previousFlip.vertical !== flip.vertical,\r\n\t};\r\n\r\n\tif (changed.horizontal || changed.vertical) {\r\n\t\tconst imageCenter = rotatePoint(\r\n\t\t\t{\r\n\t\t\t\tleft: imageSize.width / 2,\r\n\t\t\t\ttop: imageSize.height / 2,\r\n\t\t\t},\r\n\t\t\t-rotate,\r\n\t\t);\r\n\r\n\t\tlet oldCenter = rotatePoint(getCenter(coordinates), -rotate);\r\n\t\tlet newCenter = rotatePoint(\r\n\t\t\t{\r\n\t\t\t\tleft: changed.horizontal ? imageCenter.left - (oldCenter.left - imageCenter.left) : oldCenter.left,\r\n\t\t\t\ttop: changed.vertical ? imageCenter.top - (oldCenter.top - imageCenter.top) : oldCenter.top,\r\n\t\t\t},\r\n\t\t\trotate,\r\n\t\t);\r\n\t\tcoordinates = applyMove(coordinates, diff(newCenter, getCenter(coordinates)));\r\n\r\n\t\toldCenter = rotatePoint(getCenter(visibleArea), -rotate);\r\n\t\tnewCenter = rotatePoint(\r\n\t\t\t{\r\n\t\t\t\tleft: changed.horizontal ? imageCenter.left - (oldCenter.left - imageCenter.left) : oldCenter.left,\r\n\t\t\t\ttop: changed.vertical ? imageCenter.top - (oldCenter.top - imageCenter.top) : oldCenter.top,\r\n\t\t\t},\r\n\t\t\trotate,\r\n\t\t);\r\n\t\tvisibleArea = applyMove(visibleArea, diff(newCenter, getCenter(visibleArea)));\r\n\r\n\t\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\t}\r\n\r\n\treturn {\r\n\t\tcoordinates,\r\n\t\tvisibleArea,\r\n\t};\r\n}\r\n","import { MoveEvent, ResizeEvent } from '../events';\r\nimport { AspectRatio, Coordinates, Limits, PositionRestrictions, ResizeDirections, SizeRestrictions } from '../typings';\r\nimport { ALL_DIRECTIONS, HORIZONTAL_DIRECTIONS, VERTICAL_DIRECTIONS } from '../constants';\r\nimport { applyDirections, getBrokenRatio, getIntersections, ratio } from '../service';\r\nimport { move } from './move';\r\n\r\ninterface FitConditionsParams {\r\n\tdirections: ResizeDirections;\r\n\tcoordinates: Coordinates;\r\n\tpositionRestrictions: Limits;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpreserveRatio?: boolean;\r\n\tcompensate?: boolean;\r\n}\r\n\r\nexport function fitConditions({\r\n\tdirections,\r\n\tcoordinates,\r\n\tpositionRestrictions = {},\r\n\tsizeRestrictions,\r\n\tpreserveRatio,\r\n\tcompensate,\r\n}: FitConditionsParams): ResizeDirections {\r\n\tconst fittedDirections = { ...directions };\r\n\r\n\tlet currentWidth = applyDirections(coordinates, fittedDirections).width;\r\n\tlet currentHeight = applyDirections(coordinates, fittedDirections).height;\r\n\r\n\t// Prevent strange resizes when the width or height of stencil becomes smaller than 0\r\n\tif (currentWidth < 0) {\r\n\t\tif (fittedDirections.left < 0 && fittedDirections.right < 0) {\r\n\t\t\tfittedDirections.left =\r\n\t\t\t\t-(coordinates.width - sizeRestrictions.minWidth) / (fittedDirections.left / fittedDirections.right);\r\n\t\t\tfittedDirections.right =\r\n\t\t\t\t-(coordinates.width - sizeRestrictions.minWidth) / (fittedDirections.right / fittedDirections.left);\r\n\t\t} else if (fittedDirections.left < 0) {\r\n\t\t\tfittedDirections.left = -(coordinates.width - sizeRestrictions.minWidth);\r\n\t\t} else if (fittedDirections.right < 0) {\r\n\t\t\tfittedDirections.right = -(coordinates.width - sizeRestrictions.minWidth);\r\n\t\t}\r\n\t}\r\n\tif (currentHeight < 0) {\r\n\t\tif (fittedDirections.top < 0 && fittedDirections.bottom < 0) {\r\n\t\t\tfittedDirections.top =\r\n\t\t\t\t-(coordinates.height - sizeRestrictions.minHeight) / (fittedDirections.top / fittedDirections.bottom);\r\n\t\t\tfittedDirections.bottom =\r\n\t\t\t\t-(coordinates.height - sizeRestrictions.minHeight) / (fittedDirections.bottom / fittedDirections.top);\r\n\t\t} else if (fittedDirections.top < 0) {\r\n\t\t\tfittedDirections.top = -(coordinates.height - sizeRestrictions.minHeight);\r\n\t\t} else if (fittedDirections.bottom < 0) {\r\n\t\t\tfittedDirections.bottom = -(coordinates.height - sizeRestrictions.minHeight);\r\n\t\t}\r\n\t}\r\n\r\n\t// Prevent breaking limits\r\n\tlet breaks = getIntersections(applyDirections(coordinates, fittedDirections), positionRestrictions);\r\n\r\n\tif (compensate) {\r\n\t\tif (breaks.left && breaks.left > 0 && breaks.right === 0) {\r\n\t\t\tfittedDirections.right += breaks.left;\r\n\t\t\tfittedDirections.left -= breaks.left;\r\n\t\t} else if (breaks.right && breaks.right > 0 && breaks.left === 0) {\r\n\t\t\tfittedDirections.left += breaks.right;\r\n\t\t\tfittedDirections.right -= breaks.right;\r\n\t\t}\r\n\r\n\t\tif (breaks.top && breaks.top > 0 && breaks.bottom === 0) {\r\n\t\t\tfittedDirections.bottom += breaks.top;\r\n\t\t\tfittedDirections.top -= breaks.top;\r\n\t\t} else if (breaks.bottom && breaks.bottom > 0 && breaks.top === 0) {\r\n\t\t\tfittedDirections.top += breaks.bottom;\r\n\t\t\tfittedDirections.bottom -= breaks.bottom;\r\n\t\t}\r\n\r\n\t\tbreaks = getIntersections(applyDirections(coordinates, fittedDirections), positionRestrictions);\r\n\t}\r\n\r\n\tconst maxResize = {\r\n\t\twidth: Infinity,\r\n\t\theight: Infinity,\r\n\t\tleft: Infinity,\r\n\t\tright: Infinity,\r\n\t\ttop: Infinity,\r\n\t\tbottom: Infinity,\r\n\t};\r\n\r\n\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\tconst intersection = breaks[direction];\r\n\t\tif (intersection && fittedDirections[direction]) {\r\n\t\t\tmaxResize[direction] = Math.max(0, 1 - intersection / fittedDirections[direction]);\r\n\t\t}\r\n\t});\r\n\r\n\tif (preserveRatio) {\r\n\t\tconst multiplier = Math.min(...ALL_DIRECTIONS.map((direction) => maxResize[direction]));\r\n\t\tif (multiplier !== Infinity) {\r\n\t\t\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\t\t\tfittedDirections[direction] *= multiplier;\r\n\t\t\t});\r\n\t\t}\r\n\t} else {\r\n\t\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\t\tif (maxResize[direction] !== Infinity) {\r\n\t\t\t\tfittedDirections[direction] *= maxResize[direction];\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tcurrentWidth = applyDirections(coordinates, fittedDirections).width;\r\n\tcurrentHeight = applyDirections(coordinates, fittedDirections).height;\r\n\r\n\tif (fittedDirections.right + fittedDirections.left) {\r\n\t\tif (currentWidth > sizeRestrictions.maxWidth) {\r\n\t\t\tmaxResize.width =\r\n\t\t\t\t(sizeRestrictions.maxWidth - coordinates.width) / (fittedDirections.right + fittedDirections.left);\r\n\t\t} else if (currentWidth < sizeRestrictions.minWidth) {\r\n\t\t\tmaxResize.width =\r\n\t\t\t\t(sizeRestrictions.minWidth - coordinates.width) / (fittedDirections.right + fittedDirections.left);\r\n\t\t}\r\n\t}\r\n\r\n\tif (fittedDirections.bottom + fittedDirections.top) {\r\n\t\tif (currentHeight > sizeRestrictions.maxHeight) {\r\n\t\t\tmaxResize.height =\r\n\t\t\t\t(sizeRestrictions.maxHeight - coordinates.height) / (fittedDirections.bottom + fittedDirections.top);\r\n\t\t} else if (currentHeight < sizeRestrictions.minHeight) {\r\n\t\t\tmaxResize.height =\r\n\t\t\t\t(sizeRestrictions.minHeight - coordinates.height) / (fittedDirections.bottom + fittedDirections.top);\r\n\t\t}\r\n\t}\r\n\r\n\tif (preserveRatio) {\r\n\t\tconst multiplier = Math.min(maxResize.width, maxResize.height);\r\n\t\tif (multiplier !== Infinity) {\r\n\t\t\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\t\t\tfittedDirections[direction] *= multiplier;\r\n\t\t\t});\r\n\t\t}\r\n\t} else {\r\n\t\tif (maxResize.width !== Infinity) {\r\n\t\t\tHORIZONTAL_DIRECTIONS.forEach((direction) => {\r\n\t\t\t\tfittedDirections[direction] *= maxResize.width;\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (maxResize.height !== Infinity) {\r\n\t\t\tVERTICAL_DIRECTIONS.forEach((direction) => {\r\n\t\t\t\tfittedDirections[direction] *= maxResize.height;\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\treturn fittedDirections;\r\n}\r\n\r\nexport interface ResizeParams {\r\n\tevent: ResizeEvent;\r\n\tcoordinates: Coordinates;\r\n\taspectRatio: AspectRatio;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n}\r\n\r\nfunction distributeOverlap(overlap: number, first: number, second: number) {\r\n\tif (first == 0 && second == 0) {\r\n\t\treturn overlap / 2;\r\n\t} else if (first == 0) {\r\n\t\treturn 0;\r\n\t} else if (second == 0) {\r\n\t\treturn overlap;\r\n\t} else {\r\n\t\treturn overlap * Math.abs(first / (first + second));\r\n\t}\r\n}\r\n\r\nexport function resize(params: ResizeParams): Coordinates {\r\n\tconst { event, coordinates, aspectRatio, positionRestrictions, sizeRestrictions } = params;\r\n\tconst actualCoordinates = {\r\n\t\t...coordinates,\r\n\t\tright: coordinates.left + coordinates.width,\r\n\t\tbottom: coordinates.top + coordinates.height,\r\n\t};\r\n\r\n\tconst eventParams = event.params || {};\r\n\r\n\tlet directions = {\r\n\t\t...event.directions,\r\n\t};\r\n\r\n\tconst allowedDirections = eventParams.allowedDirections || {\r\n\t\tleft: true,\r\n\t\tright: true,\r\n\t\tbottom: true,\r\n\t\ttop: true,\r\n\t};\r\n\r\n\tif (sizeRestrictions.widthFrozen) {\r\n\t\tdirections.left = 0;\r\n\t\tdirections.right = 0;\r\n\t}\r\n\r\n\tif (sizeRestrictions.heightFrozen) {\r\n\t\tdirections.top = 0;\r\n\t\tdirections.bottom = 0;\r\n\t}\r\n\r\n\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\tif (!allowedDirections[direction]) {\r\n\t\t\tdirections[direction] = 0;\r\n\t\t}\r\n\t});\r\n\r\n\t// 1. First step: determine the safe and desired area\r\n\tdirections = fitConditions({\r\n\t\tcoordinates: actualCoordinates,\r\n\t\tdirections,\r\n\t\tsizeRestrictions: sizeRestrictions,\r\n\t\tpositionRestrictions,\r\n\t});\r\n\r\n\t// 2. Second step: fix desired box to correspondent to aspect ratio\r\n\tlet currentWidth = applyDirections(actualCoordinates, directions).width;\r\n\tlet currentHeight = applyDirections(actualCoordinates, directions).height;\r\n\r\n\t// Checks ratio:\r\n\tlet ratioBroken = eventParams.preserveRatio\r\n\t\t? ratio(actualCoordinates)\r\n\t\t: getBrokenRatio(currentWidth / currentHeight, aspectRatio);\r\n\r\n\tif (ratioBroken) {\r\n\t\tlet { respectDirection } = eventParams;\r\n\t\tif (!respectDirection) {\r\n\t\t\tif (actualCoordinates.width >= actualCoordinates.height || ratioBroken === 1) {\r\n\t\t\t\trespectDirection = 'width';\r\n\t\t\t} else {\r\n\t\t\t\trespectDirection = 'height';\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (respectDirection === 'width') {\r\n\t\t\tconst overlapHeight = currentWidth / ratioBroken - actualCoordinates.height;\r\n\t\t\tif (allowedDirections.top && allowedDirections.bottom) {\r\n\t\t\t\tconst { top, bottom } = directions;\r\n\t\t\t\tdirections.bottom = distributeOverlap(overlapHeight, bottom, top);\r\n\t\t\t\tdirections.top = distributeOverlap(overlapHeight, top, bottom);\r\n\t\t\t} else if (allowedDirections.bottom) {\r\n\t\t\t\tdirections.bottom = overlapHeight;\r\n\t\t\t} else if (allowedDirections.top) {\r\n\t\t\t\tdirections.top = overlapHeight;\r\n\t\t\t} else if (allowedDirections.right) {\r\n\t\t\t\tdirections.right = 0;\r\n\t\t\t} else if (allowedDirections.left) {\r\n\t\t\t\tdirections.left = 0;\r\n\t\t\t}\r\n\t\t} else if (respectDirection === 'height') {\r\n\t\t\tconst overlapWidth = actualCoordinates.width - currentHeight * ratioBroken;\r\n\t\t\tif (allowedDirections.left && allowedDirections.right) {\r\n\t\t\t\tconst { left, right } = directions;\r\n\t\t\t\tdirections.left = -distributeOverlap(overlapWidth, left, right);\r\n\t\t\t\tdirections.right = -distributeOverlap(overlapWidth, right, left);\r\n\t\t\t} else if (allowedDirections.left) {\r\n\t\t\t\tdirections.left = -overlapWidth;\r\n\t\t\t} else if (allowedDirections.right) {\r\n\t\t\t\tdirections.right = -overlapWidth;\r\n\t\t\t} else if (allowedDirections.top) {\r\n\t\t\t\tdirections.top = 0;\r\n\t\t\t} else if (allowedDirections.bottom) {\r\n\t\t\t\tdirections.bottom = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 3. Third step: check if desired box with correct aspect ratios break some limits and fit to this conditions\r\n\t\tdirections = fitConditions({\r\n\t\t\tdirections,\r\n\t\t\tcoordinates: actualCoordinates,\r\n\t\t\tsizeRestrictions: sizeRestrictions,\r\n\t\t\tpositionRestrictions,\r\n\t\t\tpreserveRatio: true,\r\n\t\t\tcompensate: eventParams.compensate,\r\n\t\t});\r\n\t}\r\n\r\n\t// 4. Check if ratio broken (temporary):\r\n\tcurrentWidth = applyDirections(actualCoordinates, directions).width;\r\n\tcurrentHeight = applyDirections(actualCoordinates, directions).height;\r\n\tratioBroken = eventParams.preserveRatio\r\n\t\t? ratio(actualCoordinates)\r\n\t\t: getBrokenRatio(currentWidth / currentHeight, aspectRatio);\r\n\tif (ratioBroken && Math.abs(ratioBroken - currentWidth / currentHeight) > 1e-3) {\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tconsole.error(\r\n\t\t\t\t`Something went wrong and ratio was broken: ${currentWidth / currentHeight} instead of ${ratioBroken}`,\r\n\t\t\t);\r\n\t\t}\r\n\t\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\t\tif (!allowedDirections[direction]) {\r\n\t\t\t\tdirections[direction] = 0;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\treturn move({\r\n\t\tevent: new MoveEvent({\r\n\t\t\tleft: -directions.left,\r\n\t\t\ttop: -directions.top,\r\n\t\t}),\r\n\t\tcoordinates: {\r\n\t\t\twidth: coordinates.width + directions.right + directions.left,\r\n\t\t\theight: coordinates.height + directions.top + directions.bottom,\r\n\t\t\tleft: coordinates.left,\r\n\t\t\ttop: coordinates.top,\r\n\t\t},\r\n\t\tpositionRestrictions,\r\n\t});\r\n}\r\n","<script>\r\nimport classnames from 'classnames';\r\nimport bem from 'easy-bem';\r\nimport { HandlerWrapper } from '../service';\r\n\r\nconst block = bem('vue-simple-handler');\r\nconst wrapper = bem('vue-simple-handler-wrapper');\r\n\r\nexport default {\r\n\tname: 'SimpleHandler',\r\n\tcomponents: {\r\n\t\tHandlerWrapper,\r\n\t},\r\n\tprops: {\r\n\t\tdefaultClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\thoverClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\twrapperClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\thorizontalPosition: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\tverticalPosition: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\tdisabled: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: false,\r\n\t\t},\r\n\t},\r\n\tdata() {\r\n\t\treturn {\r\n\t\t\thover: false,\r\n\t\t};\r\n\t},\r\n\tcomputed: {\r\n\t\tclasses() {\r\n\t\t\tconst options = {\r\n\t\t\t\t[this.horizontalPosition]: Boolean(this.horizontalPosition),\r\n\t\t\t\t[this.verticalPosition]: Boolean(this.verticalPosition),\r\n\t\t\t\t[`${this.horizontalPosition}-${this.verticalPosition}`]: Boolean(\r\n\t\t\t\t\tthis.verticalPosition && this.horizontalPosition,\r\n\t\t\t\t),\r\n\t\t\t\thover: this.hover,\r\n\t\t\t};\r\n\t\t\treturn {\r\n\t\t\t\tdefault: classnames(block(options), this.defaultClass, this.hover && this.hoverClass),\r\n\t\t\t\twrapper: classnames(wrapper(options), this.wrapperClass),\r\n\t\t\t};\r\n\t\t},\r\n\t},\r\n\tmethods: {\r\n\t\tonDrag(dragEvent) {\r\n\t\t\tthis.$emit('drag', dragEvent);\r\n\t\t},\r\n\t\tonEnter() {\r\n\t\t\tthis.hover = true;\r\n\t\t},\r\n\t\tonLeave() {\r\n\t\t\tthis.hover = false;\r\n\t\t},\r\n\t\tonDragEnd() {\r\n\t\t\tthis.$emit('drag-end');\r\n\t\t},\r\n\t},\r\n};\r\n</script>\r\n\r\n<template>\r\n\t<HandlerWrapper\r\n\t\t:class=\"classes.wrapper\"\r\n\t\t:vertical-position=\"verticalPosition\"\r\n\t\t:horizontal-position=\"horizontalPosition\"\r\n\t\t:disabled=\"disabled\"\r\n\t\t@drag=\"onDrag\"\r\n\t\t@drag-end=\"onDragEnd\"\r\n\t\t@enter=\"onEnter\"\r\n\t\t@leave=\"onLeave\"\r\n\t>\r\n\t\t<div :class=\"classes.default\" />\r\n\t</HandlerWrapper>\r\n</template>\r\n\r\n<style lang=\"scss\">\r\n.vue-simple-handler {\r\n\tdisplay: block;\r\n\tbackground: white;\r\n\theight: 10px;\r\n\twidth: 10px;\r\n}\r\n</style>\r\n","import { ImageTransforms } from './typings';\r\nimport { getCenter, rotatePoint, rotateSize } from './service';\r\n\r\nexport const XHR_DONE = 4;\r\n\r\nexport function prepareSource(canvas, image, { rotate, flip }) {\r\n\tconst originalSize = {\r\n\t\twidth: image.naturalWidth,\r\n\t\theight: image.naturalHeight,\r\n\t};\r\n\r\n\tconst transformedSize = rotateSize(originalSize, rotate);\r\n\r\n\tconst ctx = canvas.getContext('2d');\r\n\tcanvas.height = transformedSize.height;\r\n\tcanvas.width = transformedSize.width;\r\n\r\n\tctx.save();\r\n\r\n\t// Rotation:\r\n\tconst originalCenter = {\r\n\t\tleft: originalSize.width / 2,\r\n\t\ttop: originalSize.height / 2,\r\n\t};\r\n\r\n\tlet canvasCenter = rotatePoint(\r\n\t\tgetCenter({\r\n\t\t\tleft: 0,\r\n\t\t\ttop: 0,\r\n\t\t\t...originalSize,\r\n\t\t}),\r\n\t\trotate,\r\n\t);\r\n\r\n\tctx.translate(-(canvasCenter.left - transformedSize.width / 2), -(canvasCenter.top - transformedSize.height / 2));\r\n\tctx.rotate((rotate * Math.PI) / 180);\r\n\r\n\t// Reflection;\r\n\tctx.translate(flip.horizontal ? originalSize.width : 0, flip.vertical ? originalSize.height : 0);\r\n\tctx.scale(flip.horizontal ? -1 : 1, flip.vertical ? -1 : 1);\r\n\r\n\tctx.drawImage(image, 0, 0, originalSize.width, originalSize.height);\r\n\tctx.restore();\r\n\r\n\treturn canvas;\r\n}\r\n\r\nfunction base64ToArrayBuffer(base64) {\r\n\tbase64 = base64.replace(/^data:([^;]+);base64,/gim, '');\r\n\tconst binary = atob(base64);\r\n\tconst len = binary.length;\r\n\tconst buffer = new ArrayBuffer(len);\r\n\tconst view = new Uint8Array(buffer);\r\n\tfor (let i = 0; i < len; i++) {\r\n\t\tview[i] = binary.charCodeAt(i);\r\n\t}\r\n\treturn buffer;\r\n}\r\n\r\nfunction objectURLToBlob(url, callback) {\r\n\tconst http = new XMLHttpRequest();\r\n\thttp.open('GET', url, true);\r\n\thttp.responseType = 'blob';\r\n\thttp.onload = function () {\r\n\t\tif (this.status == 200 || this.status === 0) {\r\n\t\t\tcallback(this.response);\r\n\t\t}\r\n\t};\r\n\thttp.send();\r\n}\r\n\r\nexport function getImageTransforms(orientation: number) {\r\n\tconst result: ImageTransforms = {\r\n\t\tflip: {\r\n\t\t\thorizontal: false,\r\n\t\t\tvertical: false,\r\n\t\t},\r\n\t\trotate: 0,\r\n\t};\r\n\tif (orientation) {\r\n\t\tswitch (orientation) {\r\n\t\t\tcase 2:\r\n\t\t\t\tresult.flip.horizontal = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tresult.rotate = -180;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tresult.flip.vertical = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tresult.rotate = 90;\r\n\t\t\t\tresult.flip.vertical = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\t\tresult.rotate = 90;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 7:\r\n\t\t\t\tresult.rotate = 90;\r\n\t\t\t\tresult.flip.horizontal = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 8:\r\n\t\t\t\tresult.rotate = -90;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\nfunction getImageData(img) {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tif (img) {\r\n\t\t\t\tif (/^data:/i.test(img)) {\r\n\t\t\t\t\t// Data URL\r\n\t\t\t\t\tresolve(base64ToArrayBuffer(img));\r\n\t\t\t\t} else if (/^blob:/i.test(img)) {\r\n\t\t\t\t\t// Blob\r\n\t\t\t\t\tconst fileReader = new FileReader();\r\n\t\t\t\t\tfileReader.onload = function (e) {\r\n\t\t\t\t\t\tresolve(e.target.result);\r\n\t\t\t\t\t};\r\n\t\t\t\t\tobjectURLToBlob(img, function (blob) {\r\n\t\t\t\t\t\tfileReader.readAsArrayBuffer(blob);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Simple URL\r\n\t\t\t\t\tlet http = new XMLHttpRequest();\r\n\t\t\t\t\thttp.onreadystatechange = function () {\r\n\t\t\t\t\t\tif (http.readyState !== XHR_DONE) return;\r\n\r\n\t\t\t\t\t\tif (http.status === 200 || http.status === 0) {\r\n\t\t\t\t\t\t\tresolve(http.response);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treject('Warning: could not load an image to parse its orientation');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\thttp = null;\r\n\t\t\t\t\t};\r\n\t\t\t\t\thttp.onprogress = function () {\r\n\t\t\t\t\t\t// Abort the request directly if it not a JPEG image for better performance\r\n\t\t\t\t\t\tif (http.getResponseHeader('content-type') !== 'image/jpeg') {\r\n\t\t\t\t\t\t\thttp.abort();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\thttp.withCredentials = false;\r\n\t\t\t\t\thttp.open('GET', img, true);\r\n\t\t\t\t\thttp.responseType = 'arraybuffer';\r\n\t\t\t\t\thttp.send(null);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treject('Error: the image is empty');\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\treject(e);\r\n\t\t}\r\n\t});\r\n}\r\n\r\nexport function getStyleTransforms({ rotate, flip, scaleX, scaleY }) {\r\n\tlet transform = '';\r\n\ttransform += ` rotate(${rotate}deg) `;\r\n\ttransform += ` scaleX(${scaleX * (flip.horizontal ? -1 : 1)}) `;\r\n\ttransform += ` scaleY(${scaleY * (flip.vertical ? -1 : 1)}) `;\r\n\treturn transform;\r\n}\r\n\r\nfunction getStringFromCharCode(dataView, start, length) {\r\n\tlet str = '';\r\n\tlet i;\r\n\tfor (i = start, length += start; i < length; i++) {\r\n\t\tstr += String.fromCharCode(dataView.getUint8(i));\r\n\t}\r\n\treturn str;\r\n}\r\n\r\nfunction getOrientation(arrayBuffer) {\r\n\ttry {\r\n\t\tconst dataView = new DataView(arrayBuffer);\r\n\t\tlet orientation;\r\n\t\tlet exifIDCode;\r\n\t\tlet tiffOffset;\r\n\t\tlet littleEndian;\r\n\t\tlet app1Start;\r\n\t\tlet ifdStart;\r\n\t\t// Only handle JPEG image (start by 0xFFD8)\r\n\t\tif (dataView.getUint8(0) === 0xff && dataView.getUint8(1) === 0xd8) {\r\n\t\t\tconst length = dataView.byteLength;\r\n\t\t\tlet offset = 2;\r\n\t\t\twhile (offset + 1 < length) {\r\n\t\t\t\tif (dataView.getUint8(offset) === 0xff && dataView.getUint8(offset + 1) === 0xe1) {\r\n\t\t\t\t\tapp1Start = offset;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\toffset++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (app1Start) {\r\n\t\t\texifIDCode = app1Start + 4;\r\n\t\t\ttiffOffset = app1Start + 10;\r\n\t\t\tif (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\r\n\t\t\t\tconst endianness = dataView.getUint16(tiffOffset);\r\n\r\n\t\t\t\tlittleEndian = endianness === 0x4949;\r\n\r\n\t\t\t\tif (littleEndian || endianness === 0x4d4d /* bigEndian */) {\r\n\t\t\t\t\tif (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002a) {\r\n\t\t\t\t\t\tconst firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\r\n\t\t\t\t\t\tif (firstIFDOffset >= 0x00000008) {\r\n\t\t\t\t\t\t\tifdStart = tiffOffset + firstIFDOffset;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ifdStart) {\r\n\t\t\tconst length = dataView.getUint16(ifdStart, littleEndian);\r\n\r\n\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\tlet offset = ifdStart + i * 12 + 2;\r\n\t\t\t\tif (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {\r\n\t\t\t\t\t// 8 is the offset of the current tag's value\r\n\t\t\t\t\toffset += 8;\r\n\t\t\t\t\t// Get the original orientation value\r\n\t\t\t\t\torientation = dataView.getUint16(offset, littleEndian);\r\n\t\t\t\t\t// Override the orientation with its default value\r\n\t\t\t\t\tdataView.setUint16(offset, 1, littleEndian);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn orientation;\r\n\t} catch (error) {\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\nexport function parseImage(src: string) {\r\n\treturn new Promise((resolve) => {\r\n\t\tgetImageData(src)\r\n\t\t\t.then((data) => {\r\n\t\t\t\tresolve(\r\n\t\t\t\t\tdata\r\n\t\t\t\t\t\t? { source: src, arrayBuffer: data, orientation: getOrientation(data) }\r\n\t\t\t\t\t\t: { source: src, arrayBuffer: null, orientation: null },\r\n\t\t\t\t);\r\n\t\t\t})\r\n\t\t\t.catch((error) => {\r\n\t\t\t\tconsole.warn(error);\r\n\t\t\t\tresolve({ source: src, arrayBuffer: null, orientation: null });\r\n\t\t\t});\r\n\t});\r\n}\r\n\r\nexport function arrayBufferToDataURL(arrayBuffer) {\r\n\tconst chunks = [];\r\n\r\n\t// Chunk Typed Array for better performance\r\n\tconst chunkSize = 8192;\r\n\tlet uint8 = new Uint8Array(arrayBuffer);\r\n\r\n\twhile (uint8.length > 0) {\r\n\t\tconst value = uint8.subarray(0, chunkSize);\r\n\t\tchunks.push(String.fromCharCode.apply(null, Array.from ? Array.from(value) : value.slice()));\r\n\t\tuint8 = uint8.subarray(chunkSize);\r\n\t}\r\n\r\n\treturn `data:image/jpeg;base64,${btoa(chunks.join(''))}`;\r\n}\r\n","<script>\r\nimport bem from 'easy-bem';\r\nimport classnames from 'classnames';\r\nimport { radians } from '../../core';\r\nimport { getStyleTransforms } from '../../core/image';\r\nimport { rotateSize } from '../../core/service';\r\n\r\nconst cn = bem('vue-preview-result');\r\n\r\nexport default {\r\n\tname: 'PreviewResult',\r\n\tprops: {\r\n\t\timage: {\r\n\t\t\ttype: Object,\r\n\t\t},\r\n\t\ttransitions: {\r\n\t\t\ttype: Object,\r\n\t\t},\r\n\t\tstencilCoordinates: {\r\n\t\t\ttype: Object,\r\n\t\t\tdefault() {\r\n\t\t\t\treturn {\r\n\t\t\t\t\twidth: 0,\r\n\t\t\t\t\theight: 0,\r\n\t\t\t\t\tleft: 0,\r\n\t\t\t\t\ttop: 0,\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t},\r\n\t\timageClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t},\r\n\tcomputed: {\r\n\t\tclasses() {\r\n\t\t\treturn {\r\n\t\t\t\troot: cn(),\r\n\t\t\t\twrapper: cn('wrapper'),\r\n\t\t\t\timageWrapper: cn('image-wrapper'),\r\n\t\t\t\timage: classnames(cn('image'), this.imageClass),\r\n\t\t\t};\r\n\t\t},\r\n\t\twrapperStyle() {\r\n\t\t\tconst result = {\r\n\t\t\t\twidth: `${this.stencilCoordinates.width}px`,\r\n\t\t\t\theight: `${this.stencilCoordinates.height}px`,\r\n\t\t\t\tleft: `calc(50% - ${this.stencilCoordinates.width / 2}px)`,\r\n\t\t\t\ttop: `calc(50% - ${this.stencilCoordinates.height / 2}px)`,\r\n\t\t\t};\r\n\t\t\tif (this.transitions && this.transitions.enabled) {\r\n\t\t\t\tresult.transition = `${this.transitions.time}ms ${this.transitions.timingFunction}`;\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\timageStyle() {\r\n\t\t\tconst imageTransforms = this.image.transforms;\r\n\r\n\t\t\tconst virtualSize = rotateSize(\r\n\t\t\t\t{\r\n\t\t\t\t\twidth: this.image.width,\r\n\t\t\t\t\theight: this.image.height,\r\n\t\t\t\t},\r\n\t\t\t\timageTransforms.rotate,\r\n\t\t\t);\r\n\r\n\t\t\tconst result = {\r\n\t\t\t\twidth: `${this.image.width}px`,\r\n\t\t\t\theight: `${this.image.height}px`,\r\n\t\t\t\tleft: '0px',\r\n\t\t\t\ttop: '0px',\r\n\t\t\t};\r\n\r\n\t\t\tconst compensations = {\r\n\t\t\t\trotate: {\r\n\t\t\t\t\tleft: ((this.image.width - virtualSize.width) * imageTransforms.scaleX) / 2,\r\n\t\t\t\t\ttop: ((this.image.height - virtualSize.height) * imageTransforms.scaleY) / 2,\r\n\t\t\t\t},\r\n\t\t\t\tscale: {\r\n\t\t\t\t\tleft: ((1 - imageTransforms.scaleX) * this.image.width) / 2,\r\n\t\t\t\t\ttop: ((1 - imageTransforms.scaleY) * this.image.height) / 2,\r\n\t\t\t\t},\r\n\t\t\t};\r\n\r\n\t\t\tresult.transform =\r\n\t\t\t\t`translate(\r\n\t\t\t\t${\r\n\t\t\t\t\t-this.stencilCoordinates.left -\r\n\t\t\t\t\timageTransforms.translateX -\r\n\t\t\t\t\tcompensations.rotate.left -\r\n\t\t\t\t\tcompensations.scale.left\r\n\t\t\t\t}px,${\r\n\t\t\t\t\t-this.stencilCoordinates.top -\r\n\t\t\t\t\timageTransforms.translateY -\r\n\t\t\t\t\tcompensations.rotate.top -\r\n\t\t\t\t\tcompensations.scale.top\r\n\t\t\t\t}px) ` + getStyleTransforms(imageTransforms);\r\n\r\n\t\t\tif (this.transitions && this.transitions.enabled) {\r\n\t\t\t\tresult.transition = `${this.transitions.time}ms ${this.transitions.timingFunction}`;\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\t},\r\n};\r\n</script>\r\n\r\n<template>\r\n\t<div :class=\"classes.root\">\r\n\t\t<div ref=\"wrapper\" :class=\"classes.wrapper\" :style=\"wrapperStyle\">\r\n\t\t\t<img ref=\"image\" :src=\"image.src\" :class=\"classes.image\" :style=\"imageStyle\" />\r\n\t\t</div>\r\n\t</div>\r\n</template>\r\n\r\n<style lang=\"scss\">\r\n.vue-preview-result {\r\n\toverflow: hidden;\r\n\tbox-sizing: border-box;\r\n\tposition: absolute;\r\n\theight: 100%;\r\n\twidth: 100%;\r\n\t&__wrapper {\r\n\t\tposition: absolute;\r\n\t}\r\n\r\n\t&__image {\r\n\t\tpointer-events: none;\r\n\t\tposition: absolute;\r\n\t\tuser-select: none;\r\n\t\ttransform-origin: center;\r\n\t\twill-change: transform;\r\n\t\t// Workaround to prevent bugs at the websites with max-width\r\n\t\t// rule applied to img (Vuepress for example)\r\n\t\tmax-width: none !important;\r\n\t}\r\n}\r\n</style>\r\n","import { distance } from './utils';\r\n\r\nexport function calculateGeometricProperties(touches: Touch[], container: HTMLElement) {\r\n\tconst { left, top } = container.getBoundingClientRect();\r\n\r\n\tconst centerMass = { left: 0, top: 0 };\r\n\tlet spread = 0;\r\n\r\n\ttouches.forEach((touch) => {\r\n\t\tcenterMass.left += (touch.clientX - left) / touches.length;\r\n\t\tcenterMass.top += (touch.clientY - top) / touches.length;\r\n\t});\r\n\r\n\ttouches.forEach((touch) => {\r\n\t\tspread += distance(\r\n\t\t\t{ x: centerMass.left, y: centerMass.top },\r\n\t\t\t{ x: touch.clientX - left, y: touch.clientY - top },\r\n\t\t);\r\n\t});\r\n\r\n\treturn { centerMass, spread, count: touches.length };\r\n}\r\n","<script>\r\nimport { ManipulateImageEvent } from '../../core/events.ts';\r\nimport { calculateGeometricProperties } from '../../core/touch';\r\nimport { sign } from '../../core/utils';\r\n\r\nexport default {\r\n\tname: 'CropperWrapper',\r\n\tprops: {\r\n\t\ttouchMove: {\r\n\t\t\ttype: Boolean,\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tmouseMove: {\r\n\t\t\ttype: Boolean,\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\ttouchResize: {\r\n\t\t\ttype: Boolean,\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\twheelResize: {\r\n\t\t\ttype: [Boolean, Object],\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t},\r\n\tbeforeMount() {\r\n\t\twindow.addEventListener('mouseup', this.onMouseUp, { passive: false });\r\n\t\twindow.addEventListener('mousemove', this.onMouseMove, { passive: false });\r\n\t\twindow.addEventListener('touchmove', this.onTouchMove, { passive: false });\r\n\t\twindow.addEventListener('touchend', this.onTouchEnd, { passive: false });\r\n\t},\r\n\tbeforeDestroy() {\r\n\t\twindow.removeEventListener('mouseup', this.onMouseUp);\r\n\t\twindow.removeEventListener('mousemove', this.onMouseMove);\r\n\t\twindow.removeEventListener('touchmove', this.onTouchMove);\r\n\t\twindow.removeEventListener('touchend', this.onTouchEnd);\r\n\t},\r\n\tmounted() {\r\n\t\tthis.touches = [];\r\n\t},\r\n\tmethods: {\r\n\t\tonTouchStart(e) {\r\n\t\t\tif (e.cancelable && (this.touchMove || (this.touchResize && e.touches.length > 1))) {\r\n\t\t\t\tconst container = this.$refs.container;\r\n\t\t\t\tconst { left, top, bottom, right } = container.getBoundingClientRect();\r\n\t\t\t\tthis.touches = [...e.touches].filter(\r\n\t\t\t\t\t(touch) =>\r\n\t\t\t\t\t\ttouch.clientX > left && touch.clientX < right && touch.clientY > top && touch.clientY < bottom,\r\n\t\t\t\t);\r\n\t\t\t\tthis.oldGeometricProperties = calculateGeometricProperties(this.touches, container);\r\n\r\n\t\t\t\tif (e.preventDefault) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t\te.stopPropagation();\r\n\t\t\t}\r\n\t\t},\r\n\t\tonTouchEnd(e) {\r\n\t\t\tif (e.touches.length === 0) {\r\n\t\t\t\tthis.processEnd();\r\n\t\t\t}\r\n\t\t},\r\n\t\tonTouchMove(e) {\r\n\t\t\tif (this.touches.length) {\r\n\t\t\t\tconst touches = [...e.touches].filter(\r\n\t\t\t\t\t(touch) =>\r\n\t\t\t\t\t\t!touch.identifier ||\r\n\t\t\t\t\t\tthis.touches.find((anotherTouch) => anotherTouch.identifier === touch.identifier),\r\n\t\t\t\t);\r\n\t\t\t\tthis.processMove(e, touches);\r\n\t\t\t\tif (e.preventDefault) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t\tif (e.stopPropagation) {\r\n\t\t\t\t\te.stopPropagation();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tonMouseDown(e) {\r\n\t\t\tif (this.mouseMove && 'buttons' in e && e.buttons === 1) {\r\n\t\t\t\tconst touch = {\r\n\t\t\t\t\tfake: true,\r\n\t\t\t\t\tclientX: e.clientX,\r\n\t\t\t\t\tclientY: e.clientY,\r\n\t\t\t\t};\r\n\t\t\t\tthis.touches = [touch];\r\n\t\t\t\te.stopPropagation();\r\n\t\t\t}\r\n\t\t},\r\n\t\tonMouseMove(e) {\r\n\t\t\tif (this.touches.length) {\r\n\t\t\t\tthis.processMove(e, [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfake: true,\r\n\t\t\t\t\t\tclientX: e.clientX,\r\n\t\t\t\t\t\tclientY: e.clientY,\r\n\t\t\t\t\t},\r\n\t\t\t\t]);\r\n\t\t\t\tif (e.preventDefault && e.cancelable) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tonMouseUp() {\r\n\t\t\tthis.touches = [];\r\n\t\t},\r\n\t\tprocessMove(event, newTouches) {\r\n\t\t\tif (this.touches.length) {\r\n\t\t\t\tif (this.touches.length === 1 && newTouches.length === 1) {\r\n\t\t\t\t\tthis.$emit(\r\n\t\t\t\t\t\t'move',\r\n\t\t\t\t\t\tnew ManipulateImageEvent({\r\n\t\t\t\t\t\t\tleft: this.touches[0].clientX - newTouches[0].clientX,\r\n\t\t\t\t\t\t\ttop: this.touches[0].clientY - newTouches[0].clientY,\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t);\r\n\t\t\t\t} else if (this.touches.length > 1 && this.touchResize) {\r\n\t\t\t\t\tconst newProperties = calculateGeometricProperties(newTouches, this.$refs.container);\r\n\t\t\t\t\tconst oldProperties = this.oldGeometricProperties;\r\n\r\n\t\t\t\t\tif (oldProperties.count === newProperties.count && oldProperties.count > 1) {\r\n\t\t\t\t\t\tthis.$emit(\r\n\t\t\t\t\t\t\t'resize',\r\n\t\t\t\t\t\t\tnew ManipulateImageEvent(\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tleft: oldProperties.centerMass.left - newProperties.centerMass.left,\r\n\t\t\t\t\t\t\t\t\ttop: oldProperties.centerMass.top - newProperties.centerMass.top,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tfactor: oldProperties.spread / newProperties.spread,\r\n\t\t\t\t\t\t\t\t\tcenter: newProperties.centerMass,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t),\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.oldGeometricProperties = newProperties;\r\n\t\t\t\t}\r\n\t\t\t\tthis.touches = newTouches;\r\n\t\t\t}\r\n\t\t},\r\n\t\tprocessEnd() {\r\n\t\t\tthis.touches = [];\r\n\t\t},\r\n\t\tonWheel(event) {\r\n\t\t\tif (this.wheelResize) {\r\n\t\t\t\tconst container = this.$refs.container;\r\n\t\t\t\tconst { left, top } = container.getBoundingClientRect();\r\n\t\t\t\tconst factor = 1 + this.wheelResize.ratio * sign(event.deltaY || event.detail || event.wheelDelta);\r\n\t\t\t\tconst center = {\r\n\t\t\t\t\tleft: event.clientX - left,\r\n\t\t\t\t\ttop: event.clientY - top,\r\n\t\t\t\t};\r\n\r\n\t\t\t\tthis.$emit('resize', new ManipulateImageEvent({}, { factor, center }));\r\n\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t\tevent.stopPropagation();\r\n\t\t\t}\r\n\t\t},\r\n\t},\r\n};\r\n</script>\r\n\r\n<template>\r\n\t<div ref=\"container\" @touchstart=\"onTouchStart\" @mousedown=\"onMouseDown\" @wheel=\"onWheel\">\r\n\t\t<slot />\r\n\t</div>\r\n</template>\r\n","import { ImageSize, Point, Size, VisibleArea } from '../typings';\r\n\r\nexport interface DefaultPositionParams {\r\n\tcoordinates: Size;\r\n\timageSize?: ImageSize;\r\n\tvisibleArea?: VisibleArea;\r\n}\r\nexport function defaultPosition({ imageSize, visibleArea, coordinates }: DefaultPositionParams): Point {\r\n\tconst area = visibleArea || imageSize;\r\n\r\n\treturn {\r\n\t\tleft: (visibleArea ? visibleArea.left : 0) + area.width / 2 - coordinates.width / 2,\r\n\t\ttop: (visibleArea ? visibleArea.top : 0) + area.height / 2 - coordinates.height / 2,\r\n\t};\r\n}\r\n","import { Size, VisibleArea, Coordinates, GetAreaRestrictions, Limits, Falsy } from '../typings';\r\nimport { ratio, toLimits, intersectionLimits, fitToLimits, getIntersections, fitSize, limitsToSize } from '../service';\r\n\r\nexport interface DefaultVisibleAreaParams {\r\n\timageSize: Size;\r\n\tboundaries: Size;\r\n\tcoordinates?: Coordinates | Falsy;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n}\r\nexport function defaultVisibleArea(params: DefaultVisibleAreaParams): VisibleArea {\r\n\tconst { getAreaRestrictions, coordinates, imageSize, boundaries } = params;\r\n\r\n\tconst boundaryRatio = ratio(boundaries);\r\n\r\n\tif (coordinates) {\r\n\t\t// Visible area will try to fit reference:\r\n\t\tconst reference = {\r\n\t\t\theight: Math.max(coordinates.height, imageSize.height),\r\n\t\t\twidth: Math.max(coordinates.width, imageSize.width),\r\n\t\t};\r\n\r\n\t\tconst areaProperties = fitSize(\r\n\t\t\t{\r\n\t\t\t\twidth: ratio(reference) > boundaryRatio ? reference.width : reference.height * boundaryRatio,\r\n\t\t\t\theight: ratio(reference) > boundaryRatio ? reference.width / boundaryRatio : reference.height,\r\n\t\t\t},\r\n\t\t\tlimitsToSize(getAreaRestrictions()),\r\n\t\t);\r\n\r\n\t\t// Visible area will try to center stencil:\r\n\t\tconst visibleArea = {\r\n\t\t\tleft: coordinates.left + coordinates.width / 2 - areaProperties.width / 2,\r\n\t\t\ttop: coordinates.top + coordinates.height / 2 - areaProperties.height / 2,\r\n\t\t\twidth: areaProperties.width,\r\n\t\t\theight: areaProperties.height,\r\n\t\t};\r\n\r\n\t\t// TODO: Controversial behavior:\r\n\t\t// If the coordinates are beyond image visible area will be allowed to be beyond image alike:\r\n\t\tconst coordinatesIntersection = getIntersections(\r\n\t\t\tcoordinates,\r\n\t\t\ttoLimits({\r\n\t\t\t\tleft: 0,\r\n\t\t\t\ttop: 0,\r\n\t\t\t\t...imageSize,\r\n\t\t\t}),\r\n\t\t);\r\n\r\n\t\tconst limits: Limits = {};\r\n\r\n\t\tif (!coordinatesIntersection.left && !coordinatesIntersection.right && visibleArea.width <= imageSize.width) {\r\n\t\t\tlimits.left = 0;\r\n\t\t\tlimits.right = imageSize.width;\r\n\t\t}\r\n\r\n\t\tif (!coordinatesIntersection.top && !coordinatesIntersection.bottom && visibleArea.height <= imageSize.height) {\r\n\t\t\tlimits.top = 0;\r\n\t\t\tlimits.bottom = imageSize.height;\r\n\t\t}\r\n\r\n\t\treturn fitToLimits(visibleArea, limits);\r\n\t} else {\r\n\t\tconst imageRatio = ratio(imageSize);\r\n\r\n\t\tconst areaProperties = {\r\n\t\t\theight: imageRatio > boundaryRatio ? imageSize.height : imageSize.width / boundaryRatio,\r\n\t\t\twidth: imageRatio > boundaryRatio ? imageSize.height * boundaryRatio : imageSize.width,\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\tleft: imageSize.width / 2 - areaProperties.width / 2,\r\n\t\t\ttop: imageSize.height / 2 - areaProperties.height / 2,\r\n\t\t\twidth: areaProperties.width,\r\n\t\t\theight: areaProperties.height,\r\n\t\t};\r\n\t}\r\n}\r\n","import { Size } from '../typings';\r\nimport { ratio } from '../service';\r\n\r\nexport interface InitStretcherParams {\r\n\tstretcher: HTMLElement;\r\n\timageSize: Size;\r\n}\r\nexport function initStretcher({ stretcher, imageSize }: InitStretcherParams): void {\r\n\tconst aspectRatio = ratio(imageSize);\r\n\tstretcher.style.width = `${imageSize.width}px`;\r\n\tstretcher.style.height = `${stretcher.clientWidth / aspectRatio}px`;\r\n\t// Prevent stretching in future until stretcher will be reinitialized\r\n\tstretcher.style.width = `${stretcher.clientWidth}px`;\r\n}\r\n","import { AspectRatio, Coordinates, PositionRestrictions, SizeRestrictions, VisibleArea } from '../typings';\r\nimport { approximatedSize } from './approximatedSize';\r\nimport { applyMove, diff, fit, fitToLimits, getCenter, intersectionLimits, toLimits } from '../service';\r\n\r\nexport interface FitCoordinatesParams {\r\n\tvisibleArea: VisibleArea;\r\n\tcoordinates: Coordinates;\r\n\taspectRatio: AspectRatio;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n}\r\n\r\nexport function fitCoordinates(params: FitCoordinatesParams): Coordinates {\r\n\tconst {\r\n\t\tvisibleArea,\r\n\t\tcoordinates: previousCoordinates,\r\n\t\taspectRatio,\r\n\t\tsizeRestrictions,\r\n\t\tpositionRestrictions,\r\n\t} = params;\r\n\r\n\tlet coordinates = {\r\n\t\t...previousCoordinates,\r\n\t\t...approximatedSize({\r\n\t\t\twidth: previousCoordinates.width,\r\n\t\t\theight: previousCoordinates.height,\r\n\t\t\taspectRatio,\r\n\t\t\tsizeRestrictions: {\r\n\t\t\t\tmaxWidth: visibleArea.width,\r\n\t\t\t\tmaxHeight: visibleArea.height,\r\n\t\t\t\tminHeight: Math.min(visibleArea.height, sizeRestrictions.minHeight),\r\n\t\t\t\tminWidth: Math.min(visibleArea.width, sizeRestrictions.minWidth),\r\n\t\t\t},\r\n\t\t}),\r\n\t};\r\n\r\n\tcoordinates = applyMove(coordinates, diff(getCenter(previousCoordinates), getCenter(coordinates)));\r\n\r\n\tcoordinates = fitToLimits(coordinates, intersectionLimits(toLimits(visibleArea), positionRestrictions));\r\n\r\n\treturn coordinates;\r\n}\r\n","import {\r\n\tadjustSize,\r\n\tapplyMove,\r\n\tapplyScale,\r\n\tfit,\r\n\tfitToLimits,\r\n\tgetIntersections,\r\n\tinverseMove,\r\n\tmaxScale,\r\n\tratio,\r\n\ttoLimits,\r\n} from '../service';\r\nimport { Coordinates, AreaRestrictions, VisibleArea, Boundaries, GetAreaRestrictions } from '../typings';\r\n\r\n// This function updates visible area with respect to current transformations and fits\r\n// coordinates to the new visible area\r\nexport interface FitVisibleAreaParams {\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n\tcoordinates: Coordinates;\r\n\tvisibleArea: VisibleArea;\r\n\tboundaries: Boundaries;\r\n}\r\nexport function fitVisibleArea(params: FitVisibleAreaParams): VisibleArea {\r\n\tconst { visibleArea: previousVisibleArea, boundaries, getAreaRestrictions, coordinates } = params;\r\n\r\n\tlet visibleArea = { ...previousVisibleArea };\r\n\r\n\t// Scale visible area size to fit new boundaries:\r\n\tvisibleArea.height = visibleArea.width / ratio(boundaries);\r\n\tvisibleArea.top += (previousVisibleArea.height - visibleArea.height) / 2;\r\n\r\n\t// Scale visible area to prevent overlap coordinates\r\n\tif (coordinates.height - visibleArea.height > 0 || coordinates.width - visibleArea.width > 0) {\r\n\t\tvisibleArea = applyScale(\r\n\t\t\tvisibleArea,\r\n\t\t\tMath.max(coordinates.height / visibleArea.height, coordinates.width / visibleArea.width),\r\n\t\t);\r\n\t}\r\n\r\n\t// Scale visible area to prevent overlap area restrictions\r\n\tvisibleArea = applyScale(\r\n\t\tvisibleArea,\r\n\t\tadjustSize(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' })),\r\n\t);\r\n\r\n\t// Move visible are to prevent moving of the coordinates:\r\n\tconst move = inverseMove(fit(coordinates, toLimits(visibleArea)));\r\n\tif (visibleArea.width < coordinates.width) {\r\n\t\tmove.left = 0;\r\n\t}\r\n\tif (visibleArea.height < coordinates.height) {\r\n\t\tmove.top = 0;\r\n\t}\r\n\tvisibleArea = applyMove(visibleArea, move);\r\n\r\n\t// Move visible area to prevent overlap the area restrictions\r\n\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\r\n\treturn visibleArea;\r\n}\r\n","import { Boundaries, ImageRestriction, Limits, Size, VisibleArea } from '../typings';\r\nimport { ratio } from '../service';\r\n\r\nexport interface DynamicAreaRestrictionsParams {\r\n\timageRestriction: ImageRestriction;\r\n\timageSize: Size;\r\n\tboundaries: Boundaries;\r\n\tvisibleArea?: VisibleArea;\r\n\tcenter?: boolean;\r\n\ttype: 'resize' | 'move';\r\n}\r\nexport function dynamicAreaRestrictions(params: DynamicAreaRestrictionsParams): Limits {\r\n\tconst { visibleArea, boundaries, imageSize, imageRestriction, type } = params;\r\n\r\n\tlet limits: Limits = {};\r\n\r\n\tif (imageRestriction === 'fill-area') {\r\n\t\tlimits = {\r\n\t\t\tleft: 0,\r\n\t\t\ttop: 0,\r\n\t\t\tright: imageSize.width,\r\n\t\t\tbottom: imageSize.height,\r\n\t\t};\r\n\t} else if (imageRestriction === 'fit-area') {\r\n\t\tif (ratio(boundaries) > ratio(imageSize)) {\r\n\t\t\tlimits = {\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tbottom: imageSize.height,\r\n\t\t\t};\r\n\t\t\tif (visibleArea && type === 'move') {\r\n\t\t\t\tif (visibleArea.width > imageSize.width) {\r\n\t\t\t\t\tlimits.left = -(visibleArea.width - imageSize.width) / 2;\r\n\t\t\t\t\tlimits.right = imageSize.width - limits.left;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlimits.left = 0;\r\n\t\t\t\t\tlimits.right = imageSize.width;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlimits = {\r\n\t\t\t\tleft: 0,\r\n\t\t\t\tright: imageSize.width,\r\n\t\t\t};\r\n\t\t\tif (visibleArea && type === 'move') {\r\n\t\t\t\tif (visibleArea.height > imageSize.height) {\r\n\t\t\t\t\tlimits.top = -(visibleArea.height - imageSize.height) / 2;\r\n\t\t\t\t\tlimits.bottom = imageSize.height - limits.top;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlimits.top = 0;\r\n\t\t\t\t\tlimits.bottom = imageSize.height;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn limits;\r\n}\r\n","import { Size, SizeRestrictions } from '../typings';\r\n\r\nexport interface SizeRestrictionsParams {\r\n\timageSize: Size;\r\n\tminWidth: number;\r\n\tminHeight: number;\r\n\tmaxWidth: number;\r\n\tmaxHeight: number;\r\n}\r\nexport function percentRestrictions({\r\n\timageSize,\r\n\tminWidth,\r\n\tminHeight,\r\n\tmaxWidth,\r\n\tmaxHeight,\r\n}: SizeRestrictionsParams): SizeRestrictions {\r\n\treturn {\r\n\t\tminWidth: (minWidth / 100) * imageSize.width,\r\n\t\tminHeight: (minHeight / 100) * imageSize.height,\r\n\t\tmaxWidth: (maxWidth / 100) * imageSize.width,\r\n\t\tmaxHeight: (maxHeight / 100) * imageSize.height,\r\n\t};\r\n}\r\n\r\nexport function pixelsRestrictions({\r\n\tminWidth,\r\n\tminHeight,\r\n\tmaxWidth,\r\n\tmaxHeight,\r\n}: SizeRestrictionsParams): SizeRestrictions {\r\n\treturn {\r\n\t\tminWidth,\r\n\t\tminHeight,\r\n\t\tmaxWidth,\r\n\t\tmaxHeight,\r\n\t};\r\n}\r\n","import { ImageRestriction, Limits, Size } from '../typings';\r\n\r\nexport interface PositionRestrictionsParams {\r\n\timageRestriction: ImageRestriction;\r\n\timageSize: Size;\r\n}\r\nexport function positionRestrictions({ imageSize, imageRestriction }: PositionRestrictionsParams): Limits {\r\n\tlet limits = {};\r\n\r\n\tif (imageRestriction !== 'none') {\r\n\t\tlimits = {\r\n\t\t\tleft: 0,\r\n\t\t\ttop: 0,\r\n\t\t\tright: imageSize.width,\r\n\t\t\tbottom: imageSize.height,\r\n\t\t};\r\n\t}\r\n\r\n\treturn limits;\r\n}\r\n","import { Boundaries, ImageRestriction, PositionRestrictions, Size, SizeRestrictions, VisibleArea } from '../typings';\r\nimport { fitSize } from '../service';\r\n\r\ninterface RefineSizeRestrictionsParams {\r\n\tsizeRestrictions: Partial<SizeRestrictions>;\r\n\tpositionRestrictions: PositionRestrictions;\r\n\tboundaries: Boundaries;\r\n\timageSize: Size;\r\n\timageRestriction: ImageRestriction;\r\n}\r\nexport function refineSizeRestrictions({\r\n\tsizeRestrictions,\r\n\timageSize,\r\n\tboundaries,\r\n\tpositionRestrictions,\r\n\timageRestriction = 'none',\r\n}: RefineSizeRestrictionsParams) {\r\n\t// User can forget to set some of restrictions, so we should init them by default values\r\n\tconst restrictions = {\r\n\t\t...sizeRestrictions,\r\n\t\tminWidth: sizeRestrictions.minWidth !== undefined ? sizeRestrictions.minWidth : 0,\r\n\t\tminHeight: sizeRestrictions.minHeight !== undefined ? sizeRestrictions.minHeight : 0,\r\n\t\tmaxWidth: sizeRestrictions.maxWidth !== undefined ? sizeRestrictions.maxWidth : Infinity,\r\n\t\tmaxHeight: sizeRestrictions.maxHeight !== undefined ? sizeRestrictions.maxHeight : Infinity,\r\n\t};\r\n\r\n\t// The situation, when stencil can't be positioned in cropper due to positionRestrictions should be avoided\r\n\tif (positionRestrictions.left !== undefined && positionRestrictions.right !== undefined) {\r\n\t\trestrictions.maxWidth = Math.min(restrictions.maxWidth, positionRestrictions.right - positionRestrictions.left);\r\n\t}\r\n\tif (positionRestrictions.bottom !== undefined && positionRestrictions.top !== undefined) {\r\n\t\trestrictions.maxHeight = Math.min(\r\n\t\t\trestrictions.maxHeight,\r\n\t\t\tpositionRestrictions.bottom - positionRestrictions.top,\r\n\t\t);\r\n\t}\r\n\r\n\t// The situation when stencil larger than maximum visible area or image should be avoided if imageRestriction != 'none':\r\n\tif (imageRestriction !== 'none') {\r\n\t\tconst areaMaximum = fitSize(boundaries, imageSize);\r\n\t\tconst maxWidth = imageRestriction === 'fill-area' ? areaMaximum.width : imageSize.width;\r\n\t\tconst maxHeight = imageRestriction === 'fill-area' ? areaMaximum.height : imageSize.height;\r\n\r\n\t\tif (!restrictions.maxWidth || restrictions.maxWidth > maxWidth) {\r\n\t\t\trestrictions.maxWidth = Math.min(restrictions.maxWidth, maxWidth);\r\n\t\t}\r\n\t\tif (!restrictions.maxHeight || restrictions.maxHeight > maxHeight) {\r\n\t\t\trestrictions.maxHeight = Math.min(restrictions.maxHeight, maxHeight);\r\n\t\t}\r\n\t}\r\n\r\n\t// Process the border cases when minimum height / width larger than maximum height / width\r\n\tif (restrictions.minWidth > restrictions.maxWidth) {\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tconsole.warn(\r\n\t\t\t\t`Warning: maximum width (${restrictions.maxWidth}px) fewer that the minimum width (${restrictions.minWidth}px). It is set equal to the minimum width and width resizing was blocked`,\r\n\t\t\t);\r\n\t\t}\r\n\t\trestrictions.minWidth = restrictions.maxWidth;\r\n\t\trestrictions.widthFrozen = true;\r\n\t}\r\n\r\n\tif (restrictions.minHeight > restrictions.maxHeight) {\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tconsole.warn(\r\n\t\t\t\t`Warning: maximum height (${restrictions.maxHeight}px) fewer that the minimum height (${restrictions.minHeight}px). It is set equal to the minimum height and height resizing was blocked`,\r\n\t\t\t);\r\n\t\t}\r\n\t\trestrictions.minHeight = restrictions.maxHeight;\r\n\t\trestrictions.heightFrozen = true;\r\n\t}\r\n\r\n\treturn restrictions;\r\n}\r\n","import { Coordinates, PositionRestrictions, SizeRestrictions } from '../typings';\nimport { fitToLimits } from '../service';\n\nexport interface RoundCoordinatesParams {\n\tcoordinates: Coordinates;\n\tsizeRestrictions: SizeRestrictions;\n\tpositionRestrictions: PositionRestrictions;\n}\nexport function roundCoordinates({\n\tcoordinates,\n\tsizeRestrictions,\n\tpositionRestrictions,\n}: RoundCoordinatesParams): Coordinates {\n\tconst roundedCoordinates = {\n\t\twidth: Math.round(coordinates.width),\n\t\theight: Math.round(coordinates.height),\n\t\tleft: Math.round(coordinates.left),\n\t\ttop: Math.round(coordinates.top),\n\t};\n\n\tif (roundedCoordinates.width > sizeRestrictions.maxWidth) {\n\t\troundedCoordinates.width = Math.floor(coordinates.width);\n\t} else if (roundedCoordinates.width < sizeRestrictions.minWidth) {\n\t\troundedCoordinates.width = Math.ceil(coordinates.width);\n\t}\n\tif (roundedCoordinates.height > sizeRestrictions.maxHeight) {\n\t\troundedCoordinates.height = Math.floor(coordinates.height);\n\t} else if (roundedCoordinates.height < sizeRestrictions.minHeight) {\n\t\troundedCoordinates.height = Math.ceil(coordinates.height);\n\t}\n\n\treturn fitToLimits(roundedCoordinates, positionRestrictions);\n}\n","import { ManipulateImageEvent, MoveEvent, ResizeEvent } from '../events';\r\nimport { VisibleArea } from '../typings';\r\nimport { ALL_DIRECTIONS, MAIN_DIRECTIONS } from '../constants';\r\n\r\ninterface NormalizeEventParams {\r\n\tevent: ResizeEvent | MoveEvent | ManipulateImageEvent;\r\n\tvisibleArea: VisibleArea;\r\n\tcoefficient: number;\r\n}\r\nexport function normalizeEvent({ event, visibleArea, coefficient }: NormalizeEventParams) {\r\n\tif (event.type === 'manipulateImage') {\r\n\t\treturn {\r\n\t\t\t...event,\r\n\t\t\tmove: {\r\n\t\t\t\tleft: event.move && event.move.left ? coefficient * event.move.left : 0,\r\n\t\t\t\ttop: event.move && event.move.top ? coefficient * event.move.top : 0,\r\n\t\t\t},\r\n\t\t\tscale: {\r\n\t\t\t\tfactor: event.scale && event.scale.factor ? event.scale.factor : 1,\r\n\t\t\t\tcenter:\r\n\t\t\t\t\tevent.scale && event.scale.center\r\n\t\t\t\t\t\t? {\r\n\t\t\t\t\t\t\t\tleft: event.scale.center.left * coefficient + visibleArea.left,\r\n\t\t\t\t\t\t\t\ttop: event.scale.center.top * coefficient + visibleArea.top,\r\n\t\t\t\t\t\t  }\r\n\t\t\t\t\t\t: null,\r\n\t\t\t},\r\n\t\t};\r\n\t} else if (event.type === 'resize') {\r\n\t\tconst normalizedEvent = { ...event, directions: { ...event.directions } };\r\n\t\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\t\tnormalizedEvent.directions[direction] *= coefficient;\r\n\t\t});\r\n\t\treturn normalizedEvent;\r\n\t} else if (event.type === 'move') {\r\n\t\tconst normalizedEvent = { ...event, directions: { ...event.directions } };\r\n\t\tMAIN_DIRECTIONS.forEach((direction) => {\r\n\t\t\tnormalizedEvent.directions[direction] *= coefficient;\r\n\t\t});\r\n\t\treturn normalizedEvent;\r\n\t} else {\r\n\t\treturn event;\r\n\t}\r\n}\r\n","import { Coordinates } from './typings';\r\n\r\nexport function updateCanvas(\r\n\tcanvas: HTMLCanvasElement,\r\n\tsource: HTMLCanvasElement | HTMLImageElement,\r\n\tcoordinates: Coordinates,\r\n\tresultCoordinates?: Coordinates,\r\n) {\r\n\tcanvas.width = resultCoordinates ? resultCoordinates.width : coordinates.width;\r\n\tcanvas.height = resultCoordinates ? resultCoordinates.height : coordinates.height;\r\n\r\n\tconst ctx = canvas.getContext('2d');\r\n\tctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\tctx.drawImage(\r\n\t\tsource,\r\n\t\tcoordinates.left,\r\n\t\tcoordinates.top,\r\n\t\tcoordinates.width,\r\n\t\tcoordinates.height,\r\n\t\t0,\r\n\t\t0,\r\n\t\tcanvas.width,\r\n\t\tcanvas.height,\r\n\t);\r\n}\r\n","import { Boundaries, Size } from '../typings';\r\n\r\nexport interface DefaultBoundariesParams {\r\n\tcropper: HTMLElement;\r\n\timageSize: Size;\r\n}\r\n\r\nexport function fitBoundaries({ cropper, imageSize }: DefaultBoundariesParams): Boundaries {\r\n\tconst areaHeight = cropper.clientHeight;\r\n\tconst areaWidth = cropper.clientWidth;\r\n\r\n\tlet currentHeight = areaHeight;\r\n\tlet currentWidth = (imageSize.width * areaHeight) / imageSize.height;\r\n\r\n\tif (currentWidth > areaWidth) {\r\n\t\tcurrentWidth = areaWidth;\r\n\t\tcurrentHeight = (imageSize.height * areaWidth) / imageSize.width;\r\n\t}\r\n\r\n\treturn {\r\n\t\twidth: currentWidth,\r\n\t\theight: currentHeight,\r\n\t};\r\n}\r\n\r\nexport function fillBoundaries({ cropper }: DefaultBoundariesParams): Boundaries {\r\n\treturn {\r\n\t\twidth: cropper.clientWidth,\r\n\t\theight: cropper.clientHeight,\r\n\t};\r\n}\r\n","import { GetAreaRestrictions, Boundaries, VisibleArea } from '../typings';\r\nimport { fitToLimits, ratio } from '../service';\r\n\r\ninterface RefineVisibleAreaParams {\r\n\tvisibleArea: VisibleArea;\r\n\tboundaries: Boundaries;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n}\r\nexport function refineVisibleArea(params: RefineVisibleAreaParams): VisibleArea {\r\n\tconst { visibleArea: previousVisibleArea, boundaries, getAreaRestrictions } = params;\r\n\r\n\tlet visibleArea = { ...previousVisibleArea };\r\n\r\n\tconst boundariesRatio = ratio(boundaries);\r\n\tif (visibleArea.width / visibleArea.height !== boundariesRatio) {\r\n\t\tvisibleArea.height = visibleArea.width / boundariesRatio;\r\n\t}\r\n\r\n\treturn fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n}\r\n","import {\r\n\tAspectRatio,\r\n\tBoundaries,\r\n\tCoordinates,\r\n\tGetAreaRestrictions,\r\n\tPositionRestrictions,\r\n\tSize,\r\n\tSizeRestrictions,\r\n\tStencilSize,\r\n\tPosition,\r\n\tVisibleArea,\r\n\tStencilCalculationParams,\r\n} from '../typings';\r\nimport { isFunction, isUndefined } from '../utils';\r\nimport { adjustSize, applyScale, fitToLimits, getBrokenRatio, intersectionLimits, ratio, toLimits } from '../service';\r\nimport { approximatedSize } from './approximatedSize';\r\n\r\nexport interface CalculateStencilSizeParams {\r\n\taspectRatio: AspectRatio;\r\n\tstencilSize: StencilSize;\r\n\tboundaries: Boundaries;\r\n}\r\nexport function calculateStencilSize(params: CalculateStencilSizeParams): Size {\r\n\tconst { boundaries, stencilSize, aspectRatio } = params;\r\n\r\n\t// Checks that coordinates has the same ratio that coordinates:\r\n\tlet stencil = isFunction(stencilSize)\r\n\t\t? (stencilSize as Function)({ boundaries, aspectRatio })\r\n\t\t: stencilSize;\r\n\r\n\tif (getBrokenRatio(ratio(stencil), aspectRatio)) {\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tconsole.error(\r\n\t\t\t\t`[Adjusting stencil] The aspect ratio of stencil doesn't correspondent to aspect ratio limitations`,\r\n\t\t\t);\r\n\t\t}\r\n\t\tstencil = approximatedSize({\r\n\t\t\tsizeRestrictions: {\r\n\t\t\t\tmaxWidth: boundaries.width,\r\n\t\t\t\tmaxHeight: boundaries.height,\r\n\t\t\t\tminWidth: 0,\r\n\t\t\t\tminHeight: 0,\r\n\t\t\t},\r\n\t\t\twidth: stencil.width,\r\n\t\t\theight: stencil.height,\r\n\t\t\taspectRatio: {\r\n\t\t\t\tminimum: aspectRatio.minimum,\r\n\t\t\t\tmaximum: aspectRatio.maximum,\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\tif (stencil.width > boundaries.width || stencil.height > boundaries.height) {\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tconsole.error(\r\n\t\t\t\t`[Adjusting stencil] The width and height of stencil (${stencil.width}, ${stencil.height}) should be fewer or equal to the width and height of boundaries (${boundaries.width},${boundaries.height}) respectively`,\r\n\t\t\t);\r\n\t\t}\r\n\t\tstencil = approximatedSize({\r\n\t\t\tsizeRestrictions: {\r\n\t\t\t\tmaxWidth: boundaries.width,\r\n\t\t\t\tmaxHeight: boundaries.height,\r\n\t\t\t\tminWidth: 0,\r\n\t\t\t\tminHeight: 0,\r\n\t\t\t},\r\n\t\t\twidth: stencil.width,\r\n\t\t\theight: stencil.height,\r\n\t\t\taspectRatio: {\r\n\t\t\t\tminimum: ratio(stencil),\r\n\t\t\t\tmaximum: ratio(stencil),\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\r\n\treturn stencil;\r\n}\r\n","import Vue from 'vue';\nimport Cropper from './Cropper.vue';\n\nimport { RectangleStencil, CircleStencil } from './components/stencils';\n\nimport { SimpleHandler } from './components/handlers';\n\nimport { SimpleLine } from './components/lines';\n\nexport {\n\tPreviewResult,\n\tDraggableArea,\n\tBoundingBox,\n\tLineWrapper,\n\tHandlerWrapper,\n\tDraggableElement,\n\tStencilPreview,\n} from './components/service';\n\nexport { RectangleStencil, CircleStencil } from './components/stencils';\n\nexport { SimpleHandler } from './components/handlers';\n\nexport { SimpleLine } from './components/lines';\n\nexport { Preview } from './components/helpers';\n\nexport { ResizeEvent, MoveEvent, DragEvent } from './core/events';\n\nexport { default as Cropper } from './Cropper.vue';\n\nVue.component('cropper', Cropper);\nVue.component('rectangle-stencil', RectangleStencil);\nVue.component('circle-stencil', CircleStencil);\nVue.component('simple-handler', SimpleHandler);\nVue.component('simple-line', SimpleLine);\n"],"names":["hasOwn","hasOwnProperty","classNames","classes","i","arguments","length","arg","argType","push","Array","isArray","inner","apply","key","call","join","module","exports","default","window","componentName","elementOrMods","mods","element","base","Object","keys","reduce","result","name","value","debounce","func","wait","immediate","timeout","args","context","timestamp","later","last","Date","now","setTimeout","debounced","this","callNow","clear","clearTimeout","flush","__assign","assign","t","s","n","p","prototype","directionNames","hDirection","vDirection","classname","toUpperCase","slice","isLocal","url","test","isFunction","obj","constructor","isUndefined","undefined","isObject","getOptions","options","defaultScheme","falseScheme","forEach","Boolean","parseNumber","number","parsedNumber","Number","isNaN","isNumber","isObjectLike","toString","distance","firstPoint","secondPoint","Math","sqrt","pow","x","y","move","scale","type","directions","params","nativeEvent","position","previousPosition","anchor","DragEvent","_a","_b","getBoundingClientRect","left","top","normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","render","staticRenderFns","_compiled","functional","_scopeId","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","h","existing","beforeCreate","concat","beforeMount","addEventListener","onMouseUp","passive","onMouseMove","onTouchMove","onTouchEnd","beforeDestroy","removeEventListener","mounted","$refs","draggable","Error","touches","hovered","methods","onMouseOver","$emit","onMouseLeave","onTouchStart","e","cancelable","disabled","initAnchor","mean","touch","clientX","clientY","preventDefault","stopPropagation","processEnd","processMove","onMouseDown","fake","right","bottom","event","newTouches","ALL_DIRECTIONS","HORIZONTAL_DIRECTIONS","VERTICAL_DIRECTIONS","MAIN_DIRECTIONS","IMAGE_RESTRICTIONS","DEFAULT_COORDINATES","width","height","isEqual","a","b","properties","some","property","toLimits","object","diff","firstObject","secondObject","getCenter","getIntersections","limits","intersections","direction","areaLimit","objectLimit","max","applyDirections","coordinates","inverseMove","applyMove","applyScale","scaleFactor","center","progress","currentCenter","ratio","maxScale","area","min","Infinity","fit","intersection","getBrokenRatio","currentAspectRatio","aspectRatio","ratioBroken","minimum","maximum","fitSize","firstSize","secondSize","firstRatio","secondRatio","rotateSize","size","angle","radians","PI","abs","cos","sin","rotatePoint","point","adjustSize","fitToLimits","inverse","limitsToSize","limitSizeRestrictions","sizeRestrictions","minWidth","minHeight","maxWidth","maxHeight","joinLimits","firstDirection","secondDirection","intersectionLimits","validateSize","ignoreMinimum","correctRatio","approximatedSize","findBestCandidate","candidates","candidate","positionRestrictions","movedCoordinates","applyTransform","initialCoordinates","transform","imageSize","visibleArea","moveAlgorithm","prevCoordinates","newCoordinates","MoveEvent","changes","resizeAlgorithm","fixedStencilAutoZoom","precision","getAreaRestrictions","boundaries","originalCoordinates","originalVisibleArea","stencilSize","stencil","console","error","hybridStencilAutoZoom","simplestAutoZoom","widthIntersections","heightIntersections","defaultSize","optimalRatio","fixedDefaultSize","limitBy","manipulateImage","adjustStencil","areaScale","stencilScale","allowedScale","factor","scaleRestrictions","relativeCoordinates","rotateImage","previousImageSize","imageCenter","flipImage","flip","previousFlip","rotate","changed","horizontal","vertical","oldCenter","newCenter","fitConditions","preserveRatio","compensate","fittedDirections","currentWidth","currentHeight","breaks","maxResize","multiplier_1","map","multiplier_2","distributeOverlap","overlap","first","second","getImageData","img","Promise","resolve","reject","base64","replace","binary","atob","len","buffer","ArrayBuffer","view","Uint8Array","charCodeAt","base64ToArrayBuffer","fileReader_1","FileReader","onload","target","callback","blob","readAsArrayBuffer","http","XMLHttpRequest","open","responseType","status","response","send","http_1","onreadystatechange","readyState","onprogress","getResponseHeader","abort","withCredentials","getStyleTransforms","scaleX","scaleY","getOrientation","arrayBuffer","orientation_1","dataView","DataView","tiffOffset","littleEndian","app1Start","ifdStart","getUint8","length_1","byteLength","offset","start","str","String","fromCharCode","getStringFromCharCode","endianness","getUint16","firstIFDOffset","getUint32","length_2","setUint16","calculateGeometricProperties","container","centerMass","spread","count","boundaryRatio","reference","areaProperties","coordinatesIntersection","imageRatio","actualCoordinates","eventParams","allowedDirections","widthFrozen","heightFrozen","respectDirection","overlapHeight","top_1","overlapWidth","stretcher","clientWidth","previousCoordinates","previousVisibleArea","imageRestriction","restrictions","areaMaximum","warn","roundedCoordinates","round","floor","ceil","coefficient","normalizedEvent_1","normalizedEvent_2","canvas","image","originalSize","naturalWidth","naturalHeight","transformedSize","ctx","getContext","save","canvasCenter","translate","drawImage","restore","source","resultCoordinates","clearRect","cropper","areaHeight","clientHeight","areaWidth","boundariesRatio","src","then","data","orientation","catch","pageLocation","location","urlMatch","exec","urlparts","protocol","host","port","portOf","chunks","uint8","subarray","from","btoa","Vue","component","Cropper","RectangleStencil","CircleStencil","SimpleHandler","SimpleLine"],"mappings":"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"}